[{"title":"webpack中文文档（一）：四个核心概念","url":"tomasran.space/archives/nuYBhl8kXuC-kcxZKGpMxg/","content":"<p>原文链接：<a href=\"https://webpack.js.org/concepts/\" target=\"_blank\" rel=\"external\">https://webpack.js.org/concepts/</a></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>webpack是为了现代Javascript应用而诞生的一个模块打包器。它拥有<a href=\"https://webpack.js.org/configuration/\" target=\"_blank\" rel=\"external\">惊人的可配置性</a>，不过，在使用之前我们觉得你必须理解四个核心的概念。</p>\n<p>作为webpack学习之旅的一部分，我们撰写这篇文档旨在给大家展示这些概念的高度概览，不过我们也会提供特和概念相关的特定用例的链接。</p>\n<a id=\"more\"></a>\n<h3 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h3><p>webpack会根据你的应用的依赖关系创建一张图。这张图的起点被视为入口。入口告诉webpack从哪里开始，以及按照依赖关系图如何去打包。你可以将你的应用的入口看做是上下文根节点或者访问你的应用的第一个文件。</p>\n<p>在webpack中，我们通过在 <a href=\"https://webpack.js.org/configuration/\" target=\"_blank\" rel=\"external\">webpack配置对象</a> 中使用 <code>entry</code> 属性定义入口。</p>\n<p>下面是一个最简单的例子：</p>\n<p>webpack.config.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./path/to/my/entry/file.js'</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>根据你的应用的需求，可以有多种方法去声明入口。</p>\n<p><a href=\"https://webpack.js.org/concepts/entry-points/\" target=\"_blank\" rel=\"external\">了解更多！</a></p>\n<h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h3><p>当你打包完了所有的资源文件，我们仍然需要告诉webpack哪里去放置我们的应用。webpack的 <code>ouput</code> 属性描述了webpack如何去处理打包后的代码。</p>\n<p>webpack.config.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./path/to/my/entry/file.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'my-first-webpack.bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的例子，通过我们定义的 <code>output.filename</code> 和 <code>ouput.path</code> 属性去命名我们的包以及确定我们想要将它放置的位置。</p>\n<p><code>ouput</code> 属性拥有很多的配置功能，但是我们还是应该花一些时间去理解 <code>output</code> 属性更为通用的配置用例。</p>\n<p><a href=\"https://webpack.js.org/concepts/output/\" target=\"_blank\" rel=\"external\">了解更多！</a></p>\n<h3 id=\"加载器\"><a href=\"#加载器\" class=\"headerlink\" title=\"加载器\"></a>加载器</h3><p>目标是使得你项目中的所有资源文件成为webpack的关注点，而浏览器无需关心（这并不意味着所有的资源文件都需要一起打包）。webpack 将 <a href=\"https://webpack.js.org/concepts/modules/\" target=\"_blank\" rel=\"external\">每一个文件（.css，.html，scss，.jpg，etc）视为一个模块</a>。然而，webpack<br>只能理解Javascript代码。</p>\n<p><strong>当将资源文件添加到你的依赖图中时，webpack中的加载器会将涉及的所有文件统统转化成为模块。</strong></p>\n<p>从高层次上来讲，你的webpack配置主要有两个目的：</p>\n<ol>\n<li>通过特定的加载器识别需要进行转换的文件。（<code>test</code> 属性）</li>\n<li>将文件进行装换以便于它能够被添加到你的依赖图中（最终添加到你的包中）。（<code>use</code> 属性）</li>\n</ol>\n<p>webpack.config.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./path/to/my/entry/file.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'my-first-webpack.bundle.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;test: <span class=\"regexp\">/\\.(js|jsx)$/</span>, use: <span class=\"string\">'babel-loader'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的配置中我们定义了使用加载器的规则，设置了它的两个必须属性：<code>test</code> 和 <code>use</code> 。它告诉webpack编译器下面的事情：</p>\n<blockquote>\n<p> “webpack编译器，当你在分析 <code>require()/import</code> 声明中的路径时，遇到了 ‘.js’ 或者 ‘.jsx’文件，则在将它添加到打包结果之前，使用 <code>babel-loader</code> 去将它转换为模块。”</p>\n</blockquote>\n<p>当在你的webpack配置中定义规则时，需要切记你应该在 <code>module.rules</code> 下面进行定义，而不是 <code>rules</code>。不过如果你采用了错误的方式webpack也会发出提醒。</p>\n<p>关于加载器还有很多我们没有谈及的特定属性可以进行定义。</p>\n<p><a href=\"https://webpack.js.org/concepts/loaders/\" target=\"_blank\" rel=\"external\">了解更多！</a></p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>加载器是基于每个文件执行转换，而<code>plugins</code> 一般用来（但不局限于）在你的已经打包好的模块的“编译”或是“分块”    期间执行一些操作和自定义的功能（<a href=\"https://webpack.js.org/concepts/plugins/\" target=\"_blank\" rel=\"external\">或者更多</a>）。webpakc的插件系统<a href=\"https://webpack.js.org/api/plugins/\" target=\"_blank\" rel=\"external\">十分强大并且可定制</a>。</p>\n<p>为了使用一个插件，你只需要 <code>require（）</code> 它并且将它添加到 <code>plugins</code> 数组。大多数的插件都是可以通过参数进行定制的。因为你可以根据不同目的在同一配置文件中多次使用同一个插件，所以你需要使用 <code>new</code> 去初始化该插件的实例。</p>\n<p>webpack.config.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>); <span class=\"comment\">//installed via npm</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>); <span class=\"comment\">//to access built-in plugins</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./path/to/my/entry/file.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'my-first-webpack.bundle.js'</span>,</span><br><span class=\"line\">    path: <span class=\"string\">'./dist'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;test: <span class=\"regexp\">/\\.(js|jsx)$/</span>, use: <span class=\"string\">'babel-loader'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;template: <span class=\"string\">'./src/index.html'</span>&#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<p>webpack提供了很多插入即用的插件！可以查看我们的 <a href=\"https://webpack.js.org/plugins/\" target=\"_blank\" rel=\"external\">插件列表</a> 以获取更多信息。</p>\n<p>在你的webpack配置中使用插件相当轻松，然而有很多的用例更值得进一步讨论。</p>\n<p><a href=\"https://webpack.js.org/concepts/plugins/\" target=\"_blank\" rel=\"external\">了解更多！</a></p>\n"},{"title":"项目总结：Okay教育智慧平台v1.7.0.1","url":"tomasran.space/archives/byiEkaZXckBFPR1ZhtuusA/","content":"<h3 id=\"参与内容\"><a href=\"#参与内容\" class=\"headerlink\" title=\"参与内容\"></a>参与内容</h3><ul>\n<li>资源列表公共组件</li>\n<li>教学资源平台列表菜单的重构</li>\n<li>教学资源页面逻辑的重构</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"所历所思\"><a href=\"#所历所思\" class=\"headerlink\" title=\"所历所思\"></a>所历所思</h3><ul>\n<li><p><strong>代码规范相关</strong><br>一个团队的项目是否应该统一编码风格？在曾经的一家强烈追求geek风格的公司小憩了一段岁月，该司要求一个项目的编码风格应当一致。依着作为一个程序员饱受沧桑的记忆，当时使用的应该是 <a href=\"http://pre-commit.com/\" target=\"_blank\" rel=\"external\">pre-commit</a> 工具，然而这个工具却不是对代码进行智能格式化，只是定义一些编程风格规则，仍然是基于es-lint或者js-lint之类的代码风格检测工具，倘若不符合这些规则，代码commit时会提示失败，并给出代码风格不符合规则的具体日志，然后人工去修改代码。当时刚入江湖，初出茅庐，还并没有形成自己重度依赖的编程风格，一切听从组织安排。而实际上，在实践的过程中我也很喜欢这种方式，因为它尽可能地提醒了我怎样写代码才够合理。<br><br>那么以下我所能体验到的代码风格统一的优点：<br>① 整个项目一种风格，不管接触哪一部分代码，都有一个熟悉的切入点。李代桃僵之时，减轻了不少阅读障碍。这样，在项目紧张的时候，临时加入的程序员就无需花更多心思去解读每个人的编程风格，对于boss而言，效率提升自然是最佳的。<br>② 编码风格的统一，对于代码bug的减少是有裨益的，一般指定的风格规则，都会是一些编程的最佳实践，肯定不会剑走偏锋。<br>③ 利于团队和谐，这一点似乎是意料之外的事，然而细思之下，却也是有些道理。作为两只有洁癖而风格各异的程序猿，在修改彼此代码的时候很容易心生怨念，自以为是，各执一词。然而风格的事情，谁也定不准个谁是谁非，而事实上很多风格确实也并分不出高下。最难解决的争议便是没有绝对非对错的争议。这时候，一统天下无疑是最好的方式，始皇帝一统天下，不服气的，斩！世界和谐。<br><br>目前的Okay教育智慧平台项目，并没有采用统一的编码风格，因此不可避免的，呈现出一种百花齐放百家争鸣的风格景象。群雄逐鹿难免造成混乱。各自为政，在自己的管辖区域如鱼得水，而涉足别人的领地时往往不知所措，耗时良久。感觉从工程效率的角度出发，统一风格是一种很好的方式。有人会说了，这是赤裸裸的压迫！没有编码自由度！每一个新人都要学习遵守代码风格，很耗时！没错，但是个人认为这比一个项目变成万花筒要更容易被接受一点。</p>\n</li>\n<li><p><strong>产品设计相关</strong><br>此次参与的教学资源页面重构过程中，深刻体会到了从产品设计的合理性角度出发对于开发者造成的影响。在该页面中，包含的基本模块有菜单模块，关键字搜索模块，过滤条件选择模块，搜索结果展示模块等，然而在产品给出的设计中，一些不相关的内容被划分到同一概念层级中，导致程序的复杂度的上升。而同时，也苦于自己沟通不利，没有真正能够从产品的角度出发给出一些合理化的建议，也就是想要表达的思想不能叙述明确，至少不能紧扣一些产品设计的原则或者理论去应对，只好无奈地接受了这个事实。这也让我想到一个只知埋头编码的码农未来一定是不受待见的，毕竟技术为产品服务。我们更加关注的肯定是技术的应用价值，它是一项工具，便利我们去处理一些实际问题。我们不能深陷此坑，要跳出来，认识本质目的。</p>\n</li>\n</ul>\n"},{"title":"Javascript函数相关","url":"tomasran.space/archives/QvKCA14vYKd0ejUlJjdz8w/","content":"<h3 id=\"函数之重，重于泰山\"><a href=\"#函数之重，重于泰山\" class=\"headerlink\" title=\"函数之重，重于泰山\"></a>函数之重，重于泰山</h3><p>人说：在Javascript中函数是一等公民。地为之重，可见一斑。那么它应该是有一些过人之处：</p>\n<h4 id=\"函数式编程不可或缺\"><a href=\"#函数式编程不可或缺\" class=\"headerlink\" title=\"函数式编程不可或缺\"></a>函数式编程不可或缺</h4><p>Javascript是一门支持函数式编程的语言，当然这不是确立函数至尊地位的关键因素，毕竟支持函数式编程的语言不胜枚举。不过很明显，这种编程思想的核心是函数，举足轻重。</p>\n<a id=\"more\"></a>\n<h4 id=\"面向对象编程的依赖\"><a href=\"#面向对象编程的依赖\" class=\"headerlink\" title=\"面向对象编程的依赖\"></a>面向对象编程的依赖</h4><p>Javascript使用构造函数实现传统面向对象语言类的概念，构造函数与普通函数并没有任何区别，只是在命名上按照面向对象语言的习惯，统一使用大驼峰形式。</p>\n<h4 id=\"函数声明优先级更高\"><a href=\"#函数声明优先级更高\" class=\"headerlink\" title=\"函数声明优先级更高\"></a>函数声明优先级更高</h4><p>变量提升时函数声明会覆盖同名的变量，函数声明的优先级高于变量，待遇优厚。比如下面这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> fn);</span><br></pre></td></tr></table></figure>\n<p>输出的是什么？答案是’function’，函数声明优先于变量声明。</p>\n<h4 id=\"语言采用的是函数作用域\"><a href=\"#语言采用的是函数作用域\" class=\"headerlink\" title=\"语言采用的是函数作用域\"></a>语言采用的是函数作用域</h4><p>Javascript使用的是函数作用域，至少在ES6出现之前（ES6开始支持块级作用域），作用域的生成以函数为单位。</p>\n<h4 id=\"函数亦可赋值，传参\"><a href=\"#函数亦可赋值，传参\" class=\"headerlink\" title=\"函数亦可赋值，传参\"></a>函数亦可赋值，传参</h4><p>函数也可以作为参数传递，可以作为返回值返回。正是它一等公民的身份写照！在Javascript中这几乎是随处可见，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I\\'m the function inside!'</span>) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数在Javascript国土一手遮天，侵入者是不是应该先跟它打个招呼呢？</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><p>怎样去执行一个函数，在Javascript中大致有四种方式进函数调用。</p>\n<ol>\n<li>默认函数调用形式。</li>\n<li>对象方法调用形式。</li>\n<li>构造器调用形式。</li>\n<li>bind，call，apply调用。</li>\n</ol>\n<p>在此不做详述。</p>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h3><p>函数中一个非常重要的概念就是this关键字，因为它的多变性，迷惑了一代又一代青年才俊。我们在一个函数中使用this，这个this指向哪里完全取决于函数执行时的调用方式。</p>\n<p>非严格模式下，默认调用方式指向全局对象，严格模式下指向undefined；对象方法调用形式指向对象本身；构造器调用形式指向实例化后的对象；bind、call、apply调用指向传递的上下文环境。优先级是：构造函数形式 &gt; bind、call和apply &gt; 方法调用 &gt; 默认调用。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Fn = Fn.bind(obj);</span><br><span class=\"line\">Fn(<span class=\"string\">'tomas'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.name); <span class=\"comment\">// ‘tomas’</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn(<span class=\"string\">'tomasran'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.name); <span class=\"comment\">// 'tomas'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.name); <span class=\"comment\">// 'tomasran'</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，使用两种不同方式，执行被绑定了obj对象的函数Fn，第一次成功修改了obj.name值，因为Fn.bind(obj)使Fn执行时候的this指针绑定到了obj上；第二次采用构造函数调用，而结果obj.name的值并没有修改，这说明构造函数执行时内部的this指针并不是绑定到obj。结论不言而喻，在this指针的绑定上，构造函数的优先级大于bind、call、apply此类硬绑定的形式。</p>\n<p>无意中说漏了一个词：硬绑定。为此，不得不多增加一点篇幅解释一下。</p>\n<h3 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h3><p>有一种常见的现象叫做绑定丢失。这是一个什么概念？举例来说，当我们有如下这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'tomas'</span>,</span><br><span class=\"line\">  fn: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = obj.fn;</span><br><span class=\"line\">foo(); <span class=\"comment\">//  输出 'undefined'</span></span><br></pre></td></tr></table></figure>\n<p>如果我们直接调用obj.fn()，显然这是方法调用模式，this指向obj对象，输出为 ‘tomas’；但是现在我们并没有这样做，而是先将obj.fn赋给了一个变量foo，然后执行<strong>foo()</strong>，之后，便惊奇地发现输出值并非我们所期望的。这是因为此时foo直接指向了obj.fn这个函数的内存地址，此时的调用形式是默认调用，这就是所谓的绑定丢失。如何解决？答案就是采用硬绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> obj.fn.apply(obj, <span class=\"built_in\">arguments</span>)&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样，调用 <strong>foo()</strong> 就会执行绑定了obj对象的fn函数。ES5提供的bind方法就是为此需求而诞生的。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>关于函数，稍微絮叨了一番，累了，歇会儿。</p>\n"},{"title":"今日Unicode字符集及其编码方式","url":"tomasran.space/archives/F4qs05oXDOsn0hPDjHJscg/","content":"<h2 id=\"万事俱备，再唤东风\"><a href=\"#万事俱备，再唤东风\" class=\"headerlink\" title=\"万事俱备，再唤东风\"></a>万事俱备，再唤东风</h2><p>之前有讨论过关于字符编码的问题，如果对此毫无了解，可以去看看 <a href=\"http://tomasran.space/archives/1lYfLLOTOzer67ZuqHJRlg/\">关于字符集、编码字符集和字符编码</a>，这里将不再强调一些基本的概念，而是想分析一下具体的字符集及其编码方式。我们的目标锁定在Unicode，话不多说，扬帆起航！</p>\n<a id=\"more\"></a>\n<h2 id=\"Unicode的设计目标\"><a href=\"#Unicode的设计目标\" class=\"headerlink\" title=\"Unicode的设计目标\"></a>Unicode的设计目标</h2><p>Unicode的诞生，基于人们希望能够拥有一个统一字符集以容纳世界上所有字符的念想。</p>\n<p>任何改革始于矛盾。在Unicode诞生之前，各个国家为了能够让自己的语言得到支持，大量的区域特定字符集被创造出来，即便是较为通用的ASCII码字符集也只是对拉丁字母的支持度较高，而对于大量的亚洲字符却无可奈何。这给计算机制造商带来的问题就是他们必须实现所有的字符编码方案来让他们的机器可以满足不同使用者的需求，使用多语言的时候还需要在各种编码方案之间进行来回切换着实令人懊恼。</p>\n<p>矛盾如此突出，也就很自然地催生出尽快统一字符集的想法。在这样的环境下，Unicode应运而生。</p>\n<h2 id=\"Unicode的字符集编号\"><a href=\"#Unicode的字符集编号\" class=\"headerlink\" title=\"Unicode的字符集编号\"></a>Unicode的字符集编号</h2><p>Unicode字符集尽量覆盖了全世界已知的所有字符，并为未知的字符留下扩展空间，以下将做详述。</p>\n<h3 id=\"编号空间-确定字符集的范围\"><a href=\"#编号空间-确定字符集的范围\" class=\"headerlink\" title=\"编号空间 - 确定字符集的范围\"></a>编号空间 - 确定字符集的范围</h3><p>Unicode字符集编号使用的数字码空间，从 0x0000 ~ 0x10FFFF，一共1,114,112个码点（就是具有标识意义、可与其建立映射关系的数字码）。书写形式是一个前缀“U+”，后面跟上对应的数字码，例如：U+0058 就是大写拉丁字母X的Unicode编号。</p>\n<p>注意：超过4位十六进制数，不能添加数字 “0” 为开头。例如： U+01000 是非法的格式（U+0100 合法）。</p>\n<p>具体可以查看 <a href=\"http://unicode-table.com/en/\" target=\"_blank\" rel=\"external\">Unicode Character Table</a>。</p>\n<h3 id=\"平面划分-可扩展的编号空间\"><a href=\"#平面划分-可扩展的编号空间\" class=\"headerlink\" title=\"平面划分 - 可扩展的编号空间\"></a>平面划分 - 可扩展的编号空间</h3><p>Unicode将它的编号空间划分成了17个平面。我们观察一下它的编号空间：0x0000 ~ 0x10FFFF，应该很容易得出结论，它就是按照高两位的不同划分了一共 0x00 ~ 0x10（一共17）个平面，每个平面包含 16<sup>4</sup> = 65536 个码点。 </p>\n<p>其中 0x0000 ~ 0xFFFF 被称为基本多语种平面（Basic Multilingual Panel），基本多语种平面是几乎所有的现代语言字符以及大量符号的数值编码。基本多语种平面的字符用4位十六进制数就可以表示，而其余的十六个平面字符则需要5~6位十六进制数表示，称之为辅助多语种平面。下图是具体的划分：</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/unicode%E5%B9%B3%E9%9D%A2%E5%88%92%E5%88%86.png\" alt=\"unicode编码平面划分表\"></p>\n<p>我们现在所看到的Unicode字符集的编号方案已经是设计较为成熟的版本，其实Unicode诞生之初采用的是16-bit 去编号一个字符，因此提供的编码空间是 0x0000 ~ 0xFFFF，一共2<sup>16</sup>（65536）个码点，也就是现在的基本多语种平面，涵盖了最为常用的字符。但是这显然是不够的，字符的数量在日益增长，需要对这个字符集进行扩充并且能够很好的兼容之前的版本，因此便就增加了16个延续在基本多语种平面之后的辅助多语种平面。</p>\n<p>那么，为什么需要进行平面划分呢？</p>\n<p>图书馆将书籍进行分类，当需要某种类别的书时直接去对应的书架上去找会节省不少时间。将Unicode字符集划分成为不同的平面也类似，Unicode字符集的17个平面对应了17张字符编号页，计算机可以根据字符编号的高两位的不同判断应该去查询哪个编号页，这意味着内存中只需载入这一张需要的编号页就可以，否则每次都要载入全部的字符编号无疑是一种内存浪费。如此的平面划分不仅具有良好的扩展性，也具备充分的兼容性。</p>\n<h3 id=\"通用字符类型\"><a href=\"#通用字符类型\" class=\"headerlink\" title=\"通用字符类型\"></a>通用字符类型</h3><p>Unicode的每一个码点都有通用类别属性。主要的类别有：字母，标志，数字，标点，象征，分隔符和其它。这些分类可以再分割。但是并不是每一个字符都只能划分为一种通用类型。例如 U+000A 换行字符既属于控制符又属于分隔符。查看具体的 <a href=\"http://www.fileformat.info/info/unicode/category/index.htm\" target=\"_blank\" rel=\"external\">Unicode通用字符类型</a>。</p>\n<h3 id=\"码点类型\"><a href=\"#码点类型\" class=\"headerlink\" title=\"码点类型\"></a>码点类型</h3><p>上面提到Unicode字符集对字符有不同的分类，而Unicode提供的码点，也是如此。</p>\n<h4 id=\"高代理码点和低代理码点\"><a href=\"#高代理码点和低代理码点\" class=\"headerlink\" title=\"高代理码点和低代理码点\"></a>高代理码点和低代理码点</h4><p>在基本平面中，U+D800 ~ U+DBFF（1024个码点）这一码值范围被称为高代理码点，U+DC00 ~ U+DFFF（1024个码点）这一码值范围被称为低代理码点。</p>\n<p>在UTF-16编码方式（后面再做解释）中高代理码点后面紧接低代理码点便构成了一个代理对，它们代表了不在基本平面之中的1,048,576（1024 × 1024）个码点。</p>\n<h4 id=\"非字符码点\"><a href=\"#非字符码点\" class=\"headerlink\" title=\"非字符码点\"></a>非字符码点</h4><p>在Unicode的码点范围中，还有一部分码点是非字符码点，它们不能用来对字符进行编码，它们的范围是：U+FDD0 ~ U+FDEF以及任何以FFFE、FFFF结尾的码值（例如1FFFF，1FFFE，10FFFF…）。这个非字符码值的数量是固定的，一共是66个，并且也不会再增加。</p>\n<h4 id=\"保留码点\"><a href=\"#保留码点\" class=\"headerlink\" title=\"保留码点\"></a>保留码点</h4><p>就像很多编程语言中的保留字一样，Unicode码值空间也有一部分是保留码点，这部分码点可以用来映射字符但是目前还未使用。</p>\n<h4 id=\"私有码点\"><a href=\"#私有码点\" class=\"headerlink\" title=\"私有码点\"></a>私有码点</h4><p>私有码点类似于关键字，但是Unicode标准并没有对此进行明确说明，因此这些字符交换需要发送方和接收方在它们的解释上达成共识。也就是说在接收方和发送方需要事先约定好这些私有字符而不是在接收到字符时从Unicode标准中去寻找解释，现在一共有三个私有码点区段：</p>\n<ul>\n<li>U+E000 ~ U+F8FF（6400个码点）</li>\n<li>U+F0000 ~ U+FFFFD（65534个码点）</li>\n<li>U+100000 ~ U+10FFFD（65534个码点）</li>\n</ul>\n<p>以上关于Unicode字符集编号做了一个较为详细的介绍，概念性的东西稍微多一点，下面就来一起探究一下Unicode的字符编码方式吧。</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/relax-and-take-it-easy-orlando-espinosa.jpg\" alt=\"放轻松\"></p>\n<h2 id=\"Unicode的编码方式\"><a href=\"#Unicode的编码方式\" class=\"headerlink\" title=\"Unicode的编码方式\"></a>Unicode的编码方式</h2><p>在了解Unicode的编码方式之前，我们先拿ASCII码进行预热。</p>\n<p>我们知道，ASCII码字符集使用8个比特位进行编号，一共可以提供 2<sup>8</sup> = 256 个码点。可见编号空间实在是很狭小。因此，ASCII码的编码方式就是简单地查询它的字符编号表，利用字符编号表的一一映射关系进行编解码。例如我们需要编码一个字符 “A”，查ASCII码表可得 “A” 的字符集编号是65，则直接将65的二进制形式 “0100 0001” 输出；解码以8-bit为分隔，进行逆向的查表过程，例如 “0100 0001 0100 0010” 以8-bit为划分可得 “0100 0001” 和 “0100 0010”，查表可得是字符 “A” 和 “B”。这就是单字节编码方案。</p>\n<p>那么在Unicode编码中，我们是否也可以采取这种方案？答案自然是否定的。</p>\n<p>Unicode庞大的字符集决定了它并不能采取单字节编码的方案。事实上，在Unicode诞生之初，仅有对基本多语种平面BMP（即编号空间为 0x0000 ~ 0xFFFF）的定义。而表示这一编号空间需要 2<sup>16</sup>个码点，对应 16 / 8 = 2 个字节，因此，早期的Unicode采用的是二字节编码方案。</p>\n<p>如果Unicode止步于此，没有后续的扩展，似乎Unicode编码也能采用和ASCII码类似的方式，通过简单的查表法来进行编码和解码，只不过这次的分隔单位是16-bit。看上去没什么问题？其实即便如此也存在一些问题，每个字符都要写满两字节的长度就有点浪费了。例如我们只想存储字符 “A”，那么通过查表写入的二进制数据流将会是 “0000 0000 0100 0001”，有没有感觉到一点点冗长？</p>\n<p>当然了，真正的原因还是因为Unicode需要进行扩展，我们无法简单通过查表法就可以达到目的，并且，这种以字符集编号来映射二进制流的方式也让字符集编号和其编码方式过于耦合。</p>\n<p>Unicode扩展之后增加了16个辅助平面，编号空间从 0x0000 ~ 0x10FFFF，在编号空间范围内的二进制流的长度存在16位、20位、24位不等，这就很尴尬了，现在有一段二进制流数据 “0000 0010 0100 1001 0110 1110 1110 0001 0001”，想通过查表法找到指定的字符？先把这一段二进制数据做个分隔吧，采用多少位进行分隔？我并不知道，于是乎华丽丽地仆街了。</p>\n<p>鉴于此，我们需要寻找其它的编码方案来解决这个问题，不能仅仅依靠字符集编号这个一一映射关系，我们可以制定字符集编号与二进制流数据之间的转换规则，通过这个规则计算出字符编码后的值（编码）或者根据编码后的值找到对应字符（解码）。</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/06A28164-6C8F-4DE2-87C5-7DEAA193B662.png\" alt=\"\"></p>\n<p>那么接下来，就让我们接触一下现行Unicode的几种编码方案。</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/300001217806130380788056240.gif\" alt=\"\"></p>\n<h3 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h3><p>UTF-32是固定编码长度的方案。它采用4个字节（这里一个字节视为8位）去映射一个Unicode字符集的码点。4个字节可以建立的映射关系已经远远超过Unicode字符集编号空间提供的码点数量，因此，UTF-32可以简单建立4个字节码和Unicode字符集码点的对应关系。</p>\n<p>相信很容易看出来，这和查表法的道理一样。时间复杂度o(1)，优点是很快。缺点也很明显，对于处于BMP平面的常用字符，全部采用32bit存储无疑是增加了大量的存储空间，造成浪费。</p>\n<h3 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h3><p>UTF-32的编码方式简单粗暴。对于我等使用MacBook，而其硬盘价格已上天的屌丝男士来说，牺牲存储自然是不能忍受的方案。那么我们就来接触一下Unicode编码的第二种实现方式吧：UTF-16。</p>\n<p>我们的Unicode码点空间至少采用3个字节才能映射完全，2个字节不够用，4个字节又浪费，何其尴尬。UTF-16在这样的现实情况下，便萌生了揉合的想法：2个字节和4个字节我都采用，但是用它们表示的平面不一样。UTF-16将Unicode码点空间进行了划分，制定了具体的编码规则如下：</p>\n<h4 id=\"U-0000-U-D7FF-和-U-E000-U-FFFF（包含首尾）\"><a href=\"#U-0000-U-D7FF-和-U-E000-U-FFFF（包含首尾）\" class=\"headerlink\" title=\"U+0000 ~ U+D7FF 和 U+E000 ~ U+FFFF（包含首尾）\"></a>U+0000 ~ U+D7FF 和 U+E000 ~ U+FFFF（包含首尾）</h4><p>对于这段码点空间，UTF-16采用16位二进制数对其进行编码，这16位二进制数和码点编号在数值上相等。举例来说明，会将 “U+B100” 编码为 “1011000100000000”，编码的值是十六进制0xB100的二进制形式。</p>\n<h4 id=\"U-D800-U-DFFF（包含首尾）\"><a href=\"#U-D800-U-DFFF（包含首尾）\" class=\"headerlink\" title=\"U+D800 ~ U+DFFF（包含首尾）\"></a>U+D800 ~ U+DFFF（包含首尾）</h4><p>那么对于BMP平面，被遗忘的那一部分编码空间做什么用呢？</p>\n<p>Unicode标准将这段区间保留下来，为UTF-16编码提供高代理码点和低代理码点（这个概念前面有提及），并且处于这一区间的码点不会和具体的字符对应（在Unicode字符编号中 0x0401 对应了字符 “A”，而 0xD800 ~ 0xDFFF 之间的任何编号不会对应任何字符）。</p>\n<p>编码方式实际上是建立字符和二进制流的映射关系。</p>\n<h4 id=\"U-10000-U-10FFFF（包含首尾）\"><a href=\"#U-10000-U-10FFFF（包含首尾）\" class=\"headerlink\" title=\"U+10000 ~ U+10FFFF（包含首尾）\"></a>U+10000 ~ U+10FFFF（包含首尾）</h4><p>码点空间还剩下哪些呢？自然是其余16个辅助平面。</p>\n<h5 id=\"UTF-16-代理对的计算方式\"><a href=\"#UTF-16-代理对的计算方式\" class=\"headerlink\" title=\"UTF-16 代理对的计算方式\"></a>UTF-16 代理对的计算方式</h5><p>这16个辅助平面被两个16-bit的编码单元组成的代理对所表示。先贴出编码的计算方法，然后以一个具体的实例去解读：</p>\n<blockquote>\n<ol>\n<li>用辅助平面的码位减去 0x10000（结果是在 0 ~ 0xFFFFF 之内的20-bit长的值）；</li>\n<li>将上面的计算结果以10位为分隔划分为两部分（易于计算，每一部分值的范围在 0 ~ 0x3FF 之间）；</li>\n<li>高位的10比特的值加上 0xD800 得到第一个码元或称作高位代理（high surrogate），值的范围是 0xD800 ~ 0xDBFF；</li>\n<li>低位的10比特的值加上 0xDC00 得到第二个码元或称作低位代理（low surrogate），现在值的范围是 0xDC00 ~ 0xDFFF。</li>\n<li>组合高低位，构成代理对</li>\n</ol>\n</blockquote>\n<h5 id=\"来看一个栗子\"><a href=\"#来看一个栗子\" class=\"headerlink\" title=\"来看一个栗子\"></a>来看一个栗子</h5><p>看到以上计算方法是否能够豁然开朗呢？至少知道了高代理码点和低代理码点的由来和这样称呼的原因吧。现在就通过一个例子来清晰这个计算过程：</p>\n<p>假设现在我们需要将Unicode字符集中的 “U+1CCCC” 进行编码，计算过程：</p>\n<p>步骤一：减去0x10000 </p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x1CCCC</span> - <span class=\"number\">0x10000</span> = <span class=\"number\">0xCCCC</span></span><br></pre></td></tr></table></figure>\n<p>步骤二：划分高低位</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>xCCCC的二进制形式：<span class=\"number\">0000 1100</span> <span class=\"number\">1100 1100</span> <span class=\"number\">1100</span> </span><br><span class=\"line\">高<span class=\"number\">10</span>位：<span class=\"number\">00</span> <span class=\"number\">0011 0011</span>  =&gt;  <span class=\"number\">0</span>x33</span><br><span class=\"line\">低<span class=\"number\">10</span>位：<span class=\"number\">00</span> <span class=\"number\">1100 1100</span>  =&gt;  <span class=\"number\">0</span>xCC</span><br></pre></td></tr></table></figure>\n<p>步骤三：计算高位</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x33</span> + <span class=\"number\">0xD800</span> = <span class=\"number\">0xD833</span></span><br></pre></td></tr></table></figure>\n<p>步骤四：计算低位</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0xCC</span> + <span class=\"number\">0xDC00</span> = <span class=\"number\">0xDCCC</span></span><br></pre></td></tr></table></figure>\n<p>步骤五：组合</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"code\"><pre><span class=\"line\">该字符的UTF-<span class=\"number\">16</span>编码即 <span class=\"number\">0</span>xD833 <span class=\"number\">0</span>xDCCC</span><br><span class=\"line\">转化为二进制：<span class=\"number\">1101 1000</span> <span class=\"number\">0011 0011</span> <span class=\"number\">1101 1100</span> <span class=\"number\">1100 1100</span></span><br></pre></td></tr></table></figure>\n<p>这样就完成了字符 “U+1CCCC”的UTF-16编码过程。</p>\n<h5 id=\"寻找理论依据\"><a href=\"#寻找理论依据\" class=\"headerlink\" title=\"寻找理论依据\"></a>寻找理论依据</h5><p>被莫名其妙地灌输了一套计算体系，UTF-16这种编码方式的理论依据是什么呢？我们再明确一下，编码方案实际上是建立字符集中的所有字符和二进制流的一一映射关系（需要明确一下一一映射的概念？ 一一映射也称作 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%B0%84\" target=\"_blank\" rel=\"external\">双射</a>）。</p>\n<p>那么接下来我们就分析一下UTF-16是否满足了这样的条件。</p>\n<p>使用UTF-16编码方案对BMP基本多语种平面的字符进行编码显然是一一映射，它直接将字符编号的值作为编码结果输出，字符编号是唯一的，所以它们肯定是一一映射。而对于 U+D800 ~ U+DFFF 这一区段，它不对应任何的字符，因此不影响关系成立。</p>\n<p>对于其余16个辅助平面，是否是一一映射需要考虑两点：</p>\n<ol>\n<li>两个不同的字符编号是否能计算出相同的编码值？</li>\n<li>一个编码值解码是否能得到不同的字符编号？</li>\n</ol>\n<p>我们希望答案皆非，这样UTF-16编码方案才能成立。而事实上呢？可以开动脑筋想想了。</p>\n<p>首先，既然是一一映射，编码字符集和编码值在数量上至少应该是一致的。16个辅助平面总共可以提供 2<sup>16</sup> ×<br> 16 = 2<sup>20</sup> 个码点。而UTF-8采用代理对去编码一个辅助平面的字符，高代理对范围是 0xD800 ~ 0xDBFF (一共1024个)，低代理对范围是 0xDC00 ~ 0xDFFF（一共1024个），那么他们的组合一共有 1024 × 1024  = 2<sup>20</sup>种可能。果然如此，他们相等。</p>\n<p>然后我们来分析它的计算过程：16个辅助平面的字符编号在 0x10000 ~ 0x100000之间，减去0x10000后的范围在 0x0 ~ 0xFFFFF 之间，这一步过程生成的值和16个辅助平面的字符编号显然是一一映射。</p>\n<p>那么，在下面的计算中，我们来验证以上提出的两点：</p>\n<p>（1）两个不同的字符编号是否能计算出相同的编码值？</p>\n<p>将上一步的计算结果拆分为高低各10位，记作（x<sub>1</sub>，y<sub>1</sub>）。</p>\n<p>我们假设存在另一个字符编号经过这一系列计算之后会生成相同的编码值，那么将另一个字符编号记作（x<sub>2</sub>，y<sub>2</sub>）。也就是说（x<sub>1</sub>，y<sub>1</sub>）和（x<sub>2</sub>，y<sub>2</sub>）经过计算之后会得到相同的编码值。我们假设这是成立的。</p>\n<p>那么按照UTF-16编码的计算方式，也就是下列等式会成立：</p>\n<blockquote>\n<p>x<sub>1</sub> + 0xD800 = x<sub>2</sub> + 0xD800</p>\n<p>y<sub>1</sub> + 0xDC00 = y<sub>2</sub> + 0xDC00</p>\n</blockquote>\n<p>这显然得到 x<sub>1</sub> =  x<sub>2</sub>，y<sub>1</sub> =  y<sub>2</sub>，假设不成立，则结论：两个不同的字符编号经过UTF-16编码计算的结果是唯一的。</p>\n<p>（2）一个编码值解码是否能得到不同的字符编号？</p>\n<p>如果只能实现编码值的唯一而不能保证解码值的唯一显然是不合适的，接收方将无法明确你想表达的意思。</p>\n<p>我们知道UTF-16采用16-bit编码BMP平面字符，32-bit编码其余16个辅助平面字符。假设现在有一串经过UTF-16编码的二进制流，例如 “100A2000 000F00AE 10001000 00008888 11111111 00001F13 000001AE 0900 0AAAA”（随意杜撰的数据）。我们能实现解码的唯一吗？</p>\n<p>首先，如果在这一串二进制数据流中我们明确知道这16-bit是某个字符编号的结果，那32-bit是另一个字符编号的结果，换句话说，我们能将二进制数据按照字符编号结果为单位进行明确划分，这样我们就只需要按照UTF-16编码的逆向过程去解码就可以了，这个解码值的唯一性应该毋庸置疑（按照验证编码唯一性逆向推导回去很容易得出结论）。这个计算过程应该算得上是 a piece of cake吧。</p>\n<p>所以关键问题就落到在这样一串连续的二进制数据中，我们如何去按照字符编号结果为单位去划分，毕竟每个字符编号结果位数可能不一样，如果编码值的位数都是16-bit的话那以16-bit为单位划分即可，而事实并非如此，这样，我们进一步明确目标：解码的时候我们究竟是截取16位还是32位？</p>\n<p>这个时候，我们看到了代理对的作用。32位的编码值都是采用高-低位代理对的形式。高位代理的值的范围是 0xD800 ~ 0xDBFF（转化为二进制就是 1101100000000000 ~ 1101101111111111），而这一区段不在BMP平面的编码值的范围内，因此，当我们遇到这个范围内的16为二进制数据，就知道它和接下来的16位一定是组成一个代理对。这样，我们就能区分开32位和16位的编码值了。以上问题得解。</p>\n<p>唠叨了这么多，总算是验证了UTF-16编码的合理性。然而还并没有结束，接下来，就来看看现在广为流传使用的UTF-8编码格式。</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/Go_On_intertitle.jpeg\" alt=\"继续\"></p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>和UTF-16一样，UTF-8也是变长的编码方式。不过，起初它采用 1 ~ 6 个字节去编码一个字符（RFC 3629重新规定其只能编码Unicode的原有字符集 0x0 ~ 0x100000，也就是最多采用4个字节足矣）。</p>\n<p>既然是对Unicode字符集的编码，那么我们就先来看看它的编码值和Unicode编号空间的对应关系吧，别说话，接镖：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">unicode编码空间范围<br>十六进制</th>\n<th style=\"text-align:left\">UTF-8二进制编码值</th>\n<th style=\"text-align:left\">注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x0000 ~ 0x007F<br>（128个码点）</td>\n<td style=\"text-align:left\">0yyyyyyy</td>\n<td style=\"text-align:left\">编码值占一个字节，对应ASCII码的128个字符编码，二级制编码值首部是从0开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x0080 ~ 0x07FF<br>（1920个码点）</td>\n<td style=\"text-align:left\">110yyyyy 10yyyyyy</td>\n<td style=\"text-align:left\">编码值占两个字节，高位字节首部从110开始，低位字节首部从10开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x0800 ~ 0xD7FF<br>0xE000 ~ 0xFFFF<br>（61440个码点）</td>\n<td style=\"text-align:left\">1110yyyy 10yyyyyy 10yyyyyy</td>\n<td style=\"text-align:left\">编码值占三个字节，第一个字节以1110开头，后两个字节以10开头</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x010000 ~ 0x10FFFF<br>（1048576个码点）</td>\n<td style=\"text-align:left\">11110yyy 10yyyyyy 10yyyyyy 10yyyyyy</td>\n<td style=\"text-align:left\">编码值占四个字节，第一个字节以11110开头，后面的字节以10开头</td>\n</tr>\n</tbody>\n</table>\n<p>从上表中，我们可以总结出UTF-8编码值的几个特性，对于一个UTF-8编码值，假设为x：</p>\n<ol>\n<li>如果x的第一位是0，则x表示的是一个ASCII码</li>\n<li>如果x的前两位是10，则x表示的是多字节编码中的除首字节之外的某个字节</li>\n<li>如果x的前三位是110，则x表示的两字节编码的首字节</li>\n<li>如果x的前四位是1110，则x表示的是三字节编码的首字节</li>\n<li>如果x的前五位是11110，则x表示的是四字节编码的首字节</li>\n</ol>\n<p>这一规律，对于给定一段二进制，去判断该字符编码是否采用的是UTF-8编码方案是有帮助的，并且也是UTF-8解码的依据。</p>\n<p>上面讲述了Unicode编码空间和UTF-8编码结果的区间对应关系，这自然是不够的，我们需要知道详细的编码规则。</p>\n<h4 id=\"UTF-8编码过程\"><a href=\"#UTF-8编码过程\" class=\"headerlink\" title=\"UTF-8编码过程\"></a>UTF-8编码过程</h4><p>以下是UTF-8的编码值计算方式：</p>\n<blockquote>\n<ol>\n<li>根据给定字符的Unicode编号，找到对应的UTF-8编码值区间，确定未知数y的个数N；</li>\n<li>将给定的Unicode编号转为二进制形式，从最低位开始，向上截取N位（不足N位高位补0）；</li>\n<li>将上一步得到的二进制结果按顺序填充到对应区间的y上，即得该字符的UTF-8编码值。</li>\n</ol>\n</blockquote>\n<h4 id=\"吃栗子比较容易消化\"><a href=\"#吃栗子比较容易消化\" class=\"headerlink\" title=\"吃栗子比较容易消化\"></a>吃栗子比较容易消化</h4><p>例如带上圆圈和锐音符的拉丁文大写字母 Ǻ 的Unicode字符编号为U+01FA，根据上述方法的计算过程如下：</p>\n<p>步骤一：确定区间</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\">U+01FA 落在区间 <span class=\"number\">0x0080</span> ~ <span class=\"number\">0x07FF</span>，因此编码值为 110yyyyy 10yyyyyy，共<span class=\"number\">11</span>个未知数</span><br></pre></td></tr></table></figure>\n<p>步骤二：Unicode字符编码二进制化</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"code\"><pre><span class=\"line\">U+<span class=\"number\">01</span>FA 的二进制形式为 <span class=\"number\">0000 0001</span> <span class=\"number\">1111 1010</span>，从低位开始向上截取<span class=\"number\">11</span>位得到： <span class=\"number\">001 1111</span> <span class=\"number\">1010</span></span><br></pre></td></tr></table></figure>\n<p>步骤三：按顺序依次填充</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"code\"><pre><span class=\"line\">将上步的二进制结果按顺序替换y，则得到编码结果： <span class=\"number\">11000111</span> <span class=\"number\">10111010</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"UTF-8编码的优势\"><a href=\"#UTF-8编码的优势\" class=\"headerlink\" title=\"UTF-8编码的优势\"></a>UTF-8编码的优势</h4><p>技术领域的流行都有着看上去足够理智的原因：</p>\n<ol>\n<li>完美兼容ASCII码编码方案，这意味着以前的ASCII码文本不需要做任何转换就可以被UTF-8理解以及编码。</li>\n<li>UTF-8编码没有字节序的问题（了解 <a href=\"\">字节序编码方案？</a>）。</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>为了不在编码的问题上陷入恐慌，以上对Unicode编码进行了一些总结，表达了一些个人理解。前行的路上，点滴积累，弥足珍贵。</p>\n"},{"title":"坐标系变换-CSS中的绝对定位方式","url":"tomasran.space/archives/KcIEvTT4V7R-jfTM615OEQ/","content":"<h2 id=\"CSS中的经纬度\"><a href=\"#CSS中的经纬度\" class=\"headerlink\" title=\"CSS中的经纬度\"></a>CSS中的经纬度</h2><p>学过数学的孩子都应该知道，对待很多坐标系下的几何数学问题，如果执拗于题设给出的坐标系可真就太傻了，坐标系只是解决问题的辅助方法，只是某个惯性系下的相对位置（论物理对码农的重要性！），如果你不喜欢，完全可以建立确立新的坐标原点，建立新的坐标系。</p>\n<a id=\"more\"></a>\n<h2 id=\"灵活的坐标系变换才是王道\"><a href=\"#灵活的坐标系变换才是王道\" class=\"headerlink\" title=\"灵活的坐标系变换才是王道\"></a>灵活的坐标系变换才是王道</h2><p>CSS中的绝对定位方式允许我们变换定位坐标系的原点，这提供了怎样的便利性呢？</p>\n<p>举个例子，我们想在地球表面建立两座高塔，要求这两座塔的连线要和东西方向平行，并且间隔一个特定距离，这两座高塔的经纬度已知。好，开工了，呆萌呆萌的总工程师需要确定它们的具体位置，于是经过一系列灰常复杂的计算得出这两个塔相对于地球坐标系零点（格林尼兹经线和赤道线）的所有信息，然后就开始施工了。这个过程以地球的零点为参考，分别定位两座塔。如果有足够的精度保证，也似乎没有什么问题，然而，却意想不到的出现了下面的状况：</p>\n<p><img src=\"http://cl.ly/3g182e3U0X3g/%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%EF%BC%9ACSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F.png\" alt=\"灵活的坐标系变换：CSS的position定位方式\"></p>\n<p>由于计算过程中存在的一点点误差，造成了实际定位中的一些偏移。两座塔不在东西方向上排列或者两座塔的水平间距超过了预期！很抱歉，不满足客户需求，除非你拥有一个出色的PM成功游说客户忍受了这貌似理所当然的缺陷。万一客户恰好是处女座的黄金圣斗士，那么推倒它重新建一座吧。</p>\n<p>呆萌呆萌的总工程师想要重新计算一遍，精度保留到小数点后面1024位。嗯，nothing is impossible。这时候，工地上一个搬砖的少年一板砖拍在总工程师的脑门上：你是不是傻！紧接着，低调地贡献出来第二套方案：</p>\n<p><img src=\"http://cl.ly/1T2g131o1A47/%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BE%A9%E6%8A%A4%EF%BC%9ACSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F.png\" alt=\"灵活的坐标系变换：CSS的position定位方式\"></p>\n<p>精确定位A塔的位置后，B塔的位置就通过相对于A塔的距离来确定。减少了运算，避免了大基数下带来的不可忽视的误差，更加准确更加棒。高手出自民间。</p>\n<p>不错，这是一个搬砖工逆袭的故事。摆在眼前的，你是否看出来变换坐标系原点带来的诸多便利呢？答案如果是否定的，来，不妨在下面留下你的联系方式，我们可以一起探讨探讨美妙的数学。</p>\n<h2 id=\"CSS中position定位方式的坐标系变换\"><a href=\"#CSS中position定位方式的坐标系变换\" class=\"headerlink\" title=\"CSS中position定位方式的坐标系变换\"></a>CSS中position定位方式的坐标系变换</h2><p><code>position</code> 可供选择的属性值有哪些呢？我们还是去看看W3C标准提供了那些吧，其实也有很多浏览器产商自己开发了适应于自身的一些position属性，暂且不考虑这些未例入标准的，我们依然是去看看W3C的定义。Go to <a href=\"http://www.w3school.com.cn/cssref/pr_class_position.asp\" target=\"_blank\" rel=\"external\">here</a>。</p>\n<p>W3C关于 <code>position</code> 属性值的介绍简洁易懂。因此我在这里也就不长篇大论。我们需要理解的就是它的每一种属性值对应哪一个坐标系，坐标原点在哪里。</p>\n<h2 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h2><h3 id=\"“position：absolute”的情况\"><a href=\"#“position：absolute”的情况\" class=\"headerlink\" title=\"“position：absolute”的情况\"></a>“position：absolute”的情况</h3><p>在使用 <code>position:absolute</code> 绝对定位的时候，有一个地方需要留点神，即是绝对定位元素是相对于父元素的内容区域吗？还是包含边框和内边距？或者说，真正的坐标原点是内容区域的左上角，还是整个框的左上角等等，弄清楚这个问题，只需要看看下面这个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child-one</span>, <span class=\"selector-class\">.child-two</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child-one</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child-two</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'parent'</span>&gt;</span><br><span class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'child-one'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"> \t\t&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'child-two'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上代码的呈现效果是这样的：</p>\n<p><img src=\"http://cl.ly/241C1v100k19/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"\"></p>\n<p>这一显示结果可以得出：在<code>position: absolute</code> 的定位方式中，top、left的设置并不是相对于父元素的边框，而是相对于父元素除边框之外的左上角。牢记这一点，不要让它破坏了你的格局。</p>\n<p>另一方面，被定位的目标元素的边框对定位会有影响吗？它的计算方式是边框还是边框以内区域呢？我们给上面个两个元素添加边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.child-one</span>,<span class=\"selector-class\">.child-two</span> &#123;<span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid orange;&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cl.ly/2z2N363r2R2Q/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"灵活的坐标系变换：CSS的position定位方式\"></p>\n<p>结论显而易见，被定位的目标元素的边框是被计算在内的。</p>\n<p>如果想实现是目标元素关于祖先元素的边框定位呢？可以使用一些hack的方法，例如设置margin-top，margin-left为负值，或者并不设置元素边框，通过其它标签来模拟出边框的效果（因地制宜）等等。</p>\n<h2 id=\"“position：relative”的情况\"><a href=\"#“position：relative”的情况\" class=\"headerlink\" title=\"“position：relative”的情况\"></a>“position：relative”的情况</h2><p>position设置为relative的定位方式，left如果设置为百分比计算的数值是：父级元素内容区域的宽度 <em> 百分比，top值则是：父级元素内容区域的高度 </em> 百分比。那么这个left是相对于自身的除边框之外的最左边，还是相对于自身左边框的最左边的距离呢？</p>\n<p>看看下面的例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'parent'</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'child'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%EF%BC%9ACSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F.png\" alt=\"灵活的坐标系变换：CSS的position定位方式\"></p>\n<p>上图的虚线框部分是目标元素正常的位置。可见，relative定位的元素left值是左边框相对于正常位置左边框的距离。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>掌握了CSS中 <code>position</code> 的各种定位方式，则掌握了CSS定位机制的半壁江山，可以在指哪放哪的道路上越走越自信，不必担忧它是否在不同设备上拥有一致的表现。所谓懂得，便能宽心。</p>\n"},{"title":"关注代码中的圈复杂度","url":"tomasran.space/archives/0JIUXRpCu91_D8gPSbCI3g/","content":"<h2 id=\"知己知彼，国际惯例先定义\"><a href=\"#知己知彼，国际惯例先定义\" class=\"headerlink\" title=\"知己知彼，国际惯例先定义\"></a>知己知彼，国际惯例先定义</h2><p>定义自然是很重要的，知己知彼，所以游刃有余。</p>\n<p>定义：</p>\n<blockquote>\n<p>圈复杂度（Cyclomatic Complexity）是软件测试的一个衡量标准，代表程序中线性独立的路径的个数。</p>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<p>线性独立路径是指程序中至少引进一个新的处理语句集合或一个新条件的任一路径。采用流图的术语，即独立路径必须包含一条在定义路径之前不曾用到的边。</p>\n</blockquote>\n<p>圈复杂度是能够定量进行计算的。我们借助程序控制流程图来分析一下它的计算方法。</p>\n<p><img src=\"http://cl.ly/0Y2y2S300u0y/Snip20160415_2.png\" alt=\"image\"></p>\n<p>将一个简单的程序控制流程绘图如上，每一个圆圈代表程序的一个执行步骤，命名为‘节点’（命名是为了方便后面的描述）；每一个带方向的箭头表示了该程序的执行路径，命名为‘路径’。可以很清晰地看见程序中存在着循环和分支结构。</p>\n<p>那么接下来就是圈复杂度的计算公式：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\">公式<span class=\"number\">1</span>：V(G) = <span class=\"keyword\">E</span> - <span class=\"keyword\">N</span> + <span class=\"number\">2</span> * P</span><br></pre></td></tr></table></figure>\n<p>E代表控制流程图的路径数量，N代表节点数量，那么P代表的是什么？它指的是程序的构成组件的个数。而从程序的控制流图来看，直接反映是节点互相是连通的流程图的个数（每一个独立的程序都有自己的控制流图，公式1可以用来整体分析多个独立程序或方法的圈复杂度）。上例中各个节点都是相连通的，因此只有一个独立组件。</p>\n<p>对单个出入口的程序来说，P值始终为1，因此公式可以简写为：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\">公式<span class=\"number\">2</span>：V(G) = <span class=\"keyword\">E</span> - <span class=\"keyword\">N</span> + <span class=\"number\">2</span> （适用于单个出入口情况）</span><br></pre></td></tr></table></figure>\n<p>现在介绍另一种情况（做图有王小二过年的气势）：</p>\n<p><img src=\"http://cl.ly/1p462O3A3F06/Snip20160415_3.png\" alt=\"强连通图\"></p>\n<p>对于这样一个强连通的控制流图（强连通图是指有向图中的每一个节点都有至少一个流入和流出，数学形式的定义更为严谨，可以问 <a href=\"http://baike.baidu.com/link?url=2ZynNeGc5lJK8JwOyCpLOk8qjiVZQZKbrcV0RIYCq3CJ8u0imBOyA8ZKDqAHgY5SxCmzMKIYxBCBzLpEL04fwK\" target=\"_blank\" rel=\"external\">度娘</a>），计算它的圈复杂度可以采用公式：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\">公式<span class=\"number\">3</span>：V(G) = <span class=\"keyword\">E</span> - <span class=\"keyword\">N</span> + P</span><br></pre></td></tr></table></figure>\n<p>控制流图中增加了一条从终点到起点的路径，整个流图形成了一个闭环。采用公式是很正确的做法，但是如果懒到不想计算的话，对于这个闭环我们还可以采取其他的方法得到它的圈复杂度，那就是数数在这个闭环中有多少不同的线性独立回路，说的通俗易懂点，就是控制流图中循环圈圈的个数（注意：必须是可循环的圈圈，并且不包含子圈）。一个简单的图示：</p>\n<p><img src=\"http://cl.ly/0M100Z2S0M3H/Snip20160416_4.png\" alt=\"线性独立图示\"></p>\n<p>公式3还有一个听上去很正式的名字叫做 <a href=\"https://en.wikipedia.org/wiki/Betti_number\" target=\"_blank\" rel=\"external\">第一贝蒂数（the first Betti number）</a>。</p>\n<p>在编程的过程中，通过绘制程序的控制流图来计算圈复杂度，进而将其控制在一个较低水平显然是一件极其麻烦的事儿，这里有更便捷的方法来帮助降低程序圈复杂度，当然，捷径的终点必须和我们想要去的地方一致。Thomas J. McCabe 为我们证明了这一点：</p>\n<blockquote>\n<p>如果一个结构化程序只有一个进入点和一个结束点，那么它的圈复杂度等于程序中决策点（分支、条件循环）的个数加 1。</p>\n</blockquote>\n<p>这给我们的实际指导就是在编码的过程中尽量减少使用循环和分支结构。</p>\n<p>这个证明已经被推广到单个进入点，多个结束点的情况：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"code\"><pre><span class=\"line\">公式<span class=\"number\">4</span>： V(G) = π - <span class=\"keyword\">s</span> + <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>π 指的是决策点的个数，s 指的是结束点的个数。</p>\n<p>到这里，我们可以得出一个等式：</p>\n<figure class=\"highlight fix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">降低圈复杂度 </span>=<span class=\"string\"> 减少分支 + 减少循环</span></span><br></pre></td></tr></table></figure>\n<p>程序判定结构的多少与其复杂度呈正相关，而复杂度的高低和程序的质量呈负相关（判定本身就是一件伤脑经的事儿，至少纯粹是与非的判定中你就要不得不设计两种结果，对于测试来说就要增加测试用例）。我们的目标很明确，减少判定，降低圈复杂度，提高程序质量，坚持“看着舒心，用着放心”的可持续发展道路。</p>\n<p></p><h2>对症下药，如何降低 javascript 中的圈复杂度</h2><br>上面的定义和分析已经为我们在任何结构化语言的编码过程中减少圈复杂度指定了统一的大政方针：减少分支和循环的使用，那么接下来，我们就需要考虑具体的落实措施了。<p></p>\n<ul>\n<li>变量尽量初始化。减少undefined和null的出现，可以消除部分场景中的分支判断。</li>\n<li><p>使用javascript的对象Object帮助减少分支。javascript对象是一张哈希表，直接寻址寻址速度快，用它来减少分支也能提升代码执行效率。举个锤子：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a === <span class=\"string\">'dog'</span>) &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a === <span class=\"string\">'cat'</span>) &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a === <span class=\"string\">'mice'</span>) &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a === <span class=\"string\">'duck'</span>) &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a === <span class=\"string\">'pig'</span>) &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125; ...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>大量的 if-else 看上去丑陋不说，让代码的圈复杂度一路飙升，那么利用javascript的对象，我们可以这样改善代码：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> animals = &#123;</span><br><span class=\"line\">  <span class=\"string\">'dog'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">'cat'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">'mice'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">'duck'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">'pig'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">animals[a]();</span><br></pre></td></tr></table></figure>\n</code></pre><p>效率提升，圈复杂度减少，不二选择。</p>\n<ul>\n<li>当定义的函数包含进行分支判断的参数，思考是否可以将路径的选择提前。简单来说，就是判断是否可以交给它的调用函数来选择，甚至交给用户自己去选择。这适用于一部分场景，举个锤子：比如页面上有几个按钮，现在js的处理逻辑是用户点击不同按钮，在js获取点击事件传递过来的参数后判断用户点击了哪一个，然后执行相应路径代码。现在，为了消除js的这个判断过程，我们可以对于不同的按钮绑定不同的点击事件，这样就可以消除js中关于用户究竟点了哪一个的判断。</li>\n</ul>\n<p>很多的javascript代码风格检测工具都可以检测程序的圈复杂度，比如 <a href=\"https://codeclimate.com\" target=\"_blank\" rel=\"external\">Code Climate</a>等等，它们会单独检测每个函数的圈复杂度（单个函数的圈复杂度不包含其内部调用函数的圈复杂度）。对于圈复杂度过高的函数定义自然就会对你采取丑拒的姿态，比较非专业的解决方法是将内部判断部分提取出来重新定义函数，这样可以骗过分析器，但是从根本上来讲是投机取巧万万不可取也。最佳途径自然是优化代码，减少分支、循环的数量。</p>\n<h2 id=\"友情推荐，工欲善其事必先利其器\"><a href=\"#友情推荐，工欲善其事必先利其器\" class=\"headerlink\" title=\"友情推荐，工欲善其事必先利其器\"></a>友情推荐，工欲善其事必先利其器</h2><p>那么，如何去检测javascript代码的圈复杂度呢？画流程图自然不可取，数代码中的循环和分支的个数显然也不是懒惰的程序员喜欢做的（稍微复杂的代码就能让你眼冒金星）。自然去寻找一些好用的工具帮助我们提升效率，这里有两个推荐：</p>\n<ol>\n<li>在线检测网站：<a href=\"http://www.jscomplexity.org/\" target=\"_blank\" rel=\"external\">JSComplexity</a></li>\n<li>命令行检测工具：<a href=\"https://github.com/jared-stilwell/complexity-report\" target=\"_blank\" rel=\"external\">complexity-report</a></li>\n</ol>\n"},{"title":"词法作用域和动态作用域的点点剖析","url":"tomasran.space/archives/jQXql7YNdkgCoEzgWHxioA/","content":"<h2 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a>作用域和作用域链</h2><p>不同的国家制定不同的法律来依法量刑。但是法律有界限，它们只对自己的国民有着束缚之力。各国的法律只有在自己国土上才有效，才被认可，这个有效范围的限制，就是法律的作用域。</p>\n<p>作用域即是对权限的界定。作用域的主体是不可忽视的，它明确了是对什么事物的权限界定。上面所讲的，法律就是作用域的主体。</p>\n<a id=\"more\"></a>\n<p>那么什么是作用域链呢？假设现在从地方乡镇到市政府到省政府指定了不完全相同的法律。某人做了一件有违公共道德的事情，地方乡镇发现没有对该罪行制定相应的处罚措施，但是我们可是依法治国、以德治国的国家啊，不能就这样罢休！于是乡镇法院将人犯转移到市级法院，想让市法院依据指定的法律法规对其进行审判，市法院扫了一眼法律法规，也无可奈何，那就交给省法院吧（人犯走了不少路），省法院发现，哎，根据我们的法律法规，他这么做是要处刑的，哈哈，终于可以给这家伙定刑了吧，于是给他定了个xx犯的头衔。</p>\n<p>在这里，各级法院的法律法规就构成了一条法律的作用域链。我们从最底层的法院（靠人犯犯案地点最近的法院）进行向上查找，直到找到明确可以给他量刑的法律，然后名正言顺地把他打入大牢。</p>\n<p>我们可以理解为作用域就是法律制定的时候规定的有效范围，而作用域链是法律执行时候的一系列依据。</p>\n<p>在计算机中也存在着相同的概念，现在我们所要谈论的作用域，是编程语言中标识符的作用域；谈论的作用域链，是程序执行过程中标识符的取值的查找依据。</p>\n<p>因为编程语言设计的差异，目前，针对标识符，存在着两种不同的作用域规则，也就是两种不同的作用域链生成机制，一是词法作用域（Lexical Scoping），二是动态作用域（Dynamic Scoping）。它们规定了标识符（以下都称为变量）在程序中的可访问性。</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>词法作用域又称静态作用域（Static Scoping），词法作用域是根据编译的阶段进行命名（编译阶段依次经历词法分析、语法分析、语义分析等阶段），意味着变量的作用域在编译的词法分析阶段就已经确定了。</p>\n<p>词法作用域规定变量的作用域链在声明的时候就已经确定，或者说在编译的时候已经确定，在声明它的代码块内部才可以被访问。以Javascript语言为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"string\">'b'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br></pre></td></tr></table></figure>\n<p>上面的例子执行的最终结果是输出了字符 “a”、“undefined”，为什么？变量a的声明和函数f的声明都在同一个代码块中，所以在函数f的内部也可以访问到变量a，也就是外部的变量a在函数f内部访问的作用域链上；但是变量b的声明是在函数f的内部，因此不在外部代码块的作用域链上。</p>\n<p>这就是词法作用域指定的规则，需要牢记变量的作用域链是在声明时就已经生成确定。</p>\n<h2 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h2><p>说完了静态作用域，现在可以谈谈它的老对手动态作用域，动态作用域的规则是：变量的作用域链的形成是在代码执行阶段。我们从一个例子说起：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'b'</span>;</span><br><span class=\"line\">  f1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f2();</span><br></pre></td></tr></table></figure>\n<p>上面的代码采用的Javascript的语法，执行结果是什么？ 答案是 “a”。再次搬出词法作用域的规则：变量的作用域链是在声明的时候就已经确定。上段代码在声明的时候，f1中的变量a已指向最外层的变量a。因此，当执行f2的时候，f2内部重新声明的变量a，只是开辟了新的内存地址，不会覆盖最外层的变量a。在f2中调用f1，由于f1中的变量a在声明时已经确定指向了最外层的变量a，所以只要最外层的变量a的值不变，它就会输出 “a”。</p>\n<p>这是以上这段代码在静态作用域下的表现。那么现在，我们假设Javascript是采用动态作用域，上述函数的执行结果又会是什么呢？</p>\n<p>鉴于大家恐是无法通过编码去验证这一段代码，我也就只能公布一下正确答案，传递传递思想了（如果想要实践的话可以去接触接触Lisp的早期版本），这一次的输出将会是 “b”。</p>\n<p>动态作用域规则指出变量作用域的确定是在执行过程中。当语句执行到f1中的输出语句时，需要查询变量a的值，此时，动态作用域规则会根据函数的调用栈，从语句所在的函数开始，依次向外直到最外层全局环境，去搜索变量的定义直到找到为止。因此，在不知道具体执行之前，我们是无法直到f1中的变量a到底指向了哪里，这就是动态作用域设定的游戏规则。</p>\n<h2 id=\"青梅煮酒论英雄\"><a href=\"#青梅煮酒论英雄\" class=\"headerlink\" title=\"青梅煮酒论英雄\"></a>青梅煮酒论英雄</h2><p>总结来看，个人还是认为静态作用域的优势明显要强于动态，对于静态作用域，我们可以只通过分析代码文件就能够确定变量的作用域和程序的输出，无论从bug调试、编码逻辑上来看都会轻松不少，增强了程序代码的可维护性。其次，动态作用域在调用的时候动态生成作用域链肯定会影响执行的速度，从性能上来说静态占优。看看Lisp已经成功完成了向静态作用域的华丽丽转型，再看看静态作用域的语言类型压倒性的优势，似乎都足以说明问题。</p>\n"},{"title":"关于字符集、编码字符集和字符编码","url":"tomasran.space/archives/1lYfLLOTOzer67ZuqHJRlg/","content":"<h2 id=\"准备好开始\"><a href=\"#准备好开始\" class=\"headerlink\" title=\"准备好开始\"></a>准备好开始</h2><p>我不是偏执于概念，只是很多时候只有对一个词汇或者术语的定义有着明确的把握之后才会自信地去使用它们。我觉得这不至于是一件钻牛角尖的坏事情，能够清晰地辨别它们或者准确地使用它们至少令自己心里踏实，不会迷惑于其它叙述者的七嘴八舌。</p>\n<p>因此，在比较充分地接触编码这一堆看上去令人头晕脑胀的事情之前，我想有必要先明确几个概念，相信我，这将有助于我们理清思绪。</p>\n<a id=\"more\"></a>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>顾名思义，字符集是字符的集合。</p>\n<p>字符是什么？世界上各个国家的语言、符号、表情等都可以视为字符。在计算机界，一个字符是一个单位的字形、类字形单位或符号的基本信息。</p>\n<p>我所要强调的重点，是在计算机中，存在着大量不同的字符集：ASCII字符集、Unicode字符集、ISO字符集等等，它们的集合元素不尽相同，包含的字符有所差别，这和以信仰为主题而诞生的不同宗教、以工作为主题而出现的不同行业别无二致。它们都属于字符集这个大概念，但是集合元素有差别。</p>\n<p>那么为什么会有这种差别呢？作为一个中国人，我想要计算机支持的字符集里包含所有的中文，理所当然；作为一个美国人，我想要计算机支持的字符里包含所有英文字母，无可厚非；又或者只想任性地定义一套火星文，无力吐槽。假设彼此都不想要支持或包含对方的字符，这样就诞生了不同的字符集。因此，不同设计者的设计目标的差异直接导致了字符集的差别。</p>\n<p>为什么不统一一个包罗万象的字符集呢？统一的过程是漫长的，过程中的分歧也是不可避免，不过好在现在我们已经走上了这条路：Unicode字符集。</p>\n<p>字符集只是将一堆字符收集起来，划了个圈子，起了个名。</p>\n<h2 id=\"编码字符集\"><a href=\"#编码字符集\" class=\"headerlink\" title=\"编码字符集\"></a>编码字符集</h2><p>那么，编码字符集是什么？我们现在准备了一个字符集，然后给字符集中的每个字符映射一个抽象的数字，这就是编码字符集。简单的说，就是给字符集中的字符一一编号。</p>\n<p>以下是Unicode字符集的编号，具体可以参见 <a href=\"http://unicode-table.com/en/\" target=\"_blank\" rel=\"external\">Unicode字符编码表</a>。</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/unicode%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%A1%A8.png\" alt=\"Unicode字符编码表\"></p>\n<p>编码字符集建立了字符和数字码的一一映射关系。</p>\n<h2 id=\"字符编解码\"><a href=\"#字符编解码\" class=\"headerlink\" title=\"字符编解码\"></a>字符编解码</h2><p>那么，现在困惑来了，我们常说的字符编码、字符解码是什么？</p>\n<p>编码字符集是将字符集中的字符和数字建立对应关系，构成了一张映射表。它就静静地躺在那里，无声无息，并不会主动去做些什么。而我们则希望计算机在存储、发送和显示字符的时候能得到正确的结果。那么既然字符集本身无能为力，我们就需要写一套规则、一堆代码去主动处理字符的存储、发送和显示。这一步过程就是字符的编码和解码。</p>\n<p>计算机存储、发送的都是二进制流数据，明白这一点很重要。我们的问题就是如何将这些二进制数据流解析成字符，或者如何将字符用二进制数据表示。</p>\n<p>下面就通过ASCII码字符集（所谓的字符编解码，都是针对某个特定的字符集）对应的编解码方案来解释一下这个过程：</p>\n<p><img src=\"http://o6lqh5p0j.bkt.clouddn.com/AC5133B5-0FDE-4B29-B277-16EB294FDA22.png\" alt=\"ASCII码表\"></p>\n<p>上表是ASCII码的编码字符集，一张映射表，ASCII码因为字符数量的稀少，用8bit（通常说一个字节，但注意一个字节并不是总等于8bit，只是现在大部分计算机是这样而已）就可以完全表示。</p>\n<p>ASCII码的编码过程很简单，只需要根据以上这张映射表查找到对应的字节，将该字节进行存储就完成了编码过程。例如字符“A”，存储到文件中就是 “01000001”。so easy，不是吗？ASCII码字符编码就是这样简单的查表过程。解码过程也很简单，对二进制数据流按照8bit进行划分，然后也是根据以上的映射表找到对应的字符即可，例如 “0011000001010000”，划分为 “00110000” 和 “01010000”，查表可得依次是“0”、“P”。</p>\n<p>ASCII码字符集的这一套编解码方案简单的人神共愤。稍微复杂的编码方式例如针对Unicode字符集的UTF-8、UTF-16、UTF-32编码后续再论。重点是，现在我们应该能够清楚地区分字符集、编码字符集和字符编码，并且明白一种字符集只有一套编码字符集，但可以有多种字符编码方案。道理显而易见。</p>\n<p>我们通常所说的编码方式就是针对这各种字符集的不同编码方案，当再听到UTF-8，UTF-16，Big5，ISO-8859-1，GB2312等等乱七八糟的编码方式时，可以不用再感到恐慌，而是轻描淡写的一句：“哦，不过是另外一种字符集的另一种编码方式而已”。</p>\n"},{"title":"黑客与画家的影子","url":"tomasran.space/archives/C8ZzMzr8_QosYft0__Wf3A/","content":"<h2 id=\"让我先做个猜测\"><a href=\"#让我先做个猜测\" class=\"headerlink\" title=\"让我先做个猜测\"></a>让我先做个猜测</h2><p>一次偶然的凑单，我收获了这本书：《黑客与画家》。一个从来充满神秘色彩的人物，遇见一个喜欢沉浸于自我陶醉的角色，他们能摩擦出怎样的火花？</p>\n<p>我企图将自己装扮成作者，强行使用小学语文老师传授给我们的移魂大法，无奈作者离我太遥远，远在那我功力遥不可及的地方，我只能就拍着脑门瞎蒙。有一句网红，叫做不喜勿喷，但是我觉得如果实在不喜的话喷喷也无妨，毕竟我只是在瞎蒙，造谣犯法，而瞎蒙和造谣毕竟也没什么区别。</p>\n<a id=\"more\"></a>\n<p>我用我的榆木脑袋在想，作者可能是想表达这两者之间的相通之处吧：他们都属于艺术创作的范畴，绘画是艺术，编程也是艺术。否则，若只是这两者的同台竞技该让多少人摸不着头脑（那样的情况往往是走向两个极端：若非内容的高深即是表达的拙劣）。</p>\n<p>恩，我觉得想的中规中矩，但是像我这种发育健全、有血有肉的鸡蛋，号称鸡蛋中的霸主，从自身的高内涵之中挑出一两根骨头出来也不是什么难事。</p>\n<p>想想作为一只鸡蛋还是得低调，不要总尝试去碰壁，更何况我是鸡蛋中的霸主，于是乎还是决定言归正传聊聊这本书吧。</p>\n<h2 id=\"吃下去，交给消化系统去处理\"><a href=\"#吃下去，交给消化系统去处理\" class=\"headerlink\" title=\"吃下去，交给消化系统去处理\"></a>吃下去，交给消化系统去处理</h2><p>看完人物介绍，Paul Graham，viaweb的创始人，青年时代就热爱上了编程，中学时喜欢写小说（原创小说的确是一个保持创意的好点子，环境自由，人物、情节设定肆意妄为，只要写的一身正气，不给一些吃饱了饭没事干的家伙留下小辫子，完全是属于自己的地盘。作家和灵感从来是互为伯乐的嘛），而后大学主修的是哲学，研究生阶段却又‘跳槽’去主攻人工智能，博士毕业之后，他竟又出人意料地去报班美术，开始学习了绘画甚至之后以此为业。</p>\n<p>这样的人生经历，其实不能说算是有很多离奇的色彩，体现出来更多的，是一种选择上的自由（在某些软件环境里，程式般的生活让每一个表达式都觉得自己生来应该遵守某个规则，运行的上下文制定了稳固的秩序，让它们觉得一旦破坏了这种秩序便会导致全局的瘫痪而且修复无望。规则和威吓限制了自由程式的发展）。我觉得他是根据自己的喜好在过着生活，如果不是后来为了生活费而又转向编程这一项工作，可能绘画领域会多一位大师，不过鱼与熊掌不可兼得的道理应该是没有种族限制的，还是庆幸他在程序员界走了一遭，为我们沉淀了不少好东西。</p>\n<p>读完介绍，我觉得我可能要抱着一丝丝崇拜之心去读他的作品了，恭敬地掀开了第一章。</p>\n<p>说实话，第一章并没有给我带来太多好感，读着读着心情就郁闷了，感觉似乎是一个初高中时代遭受过不公平待遇的孩子在他的往事回忆录中的一种宣泄。作者已经将学校的教育体制黑的体无完肤了，在他眼中可以直接说学校其实是一种毫无必要存在的垃圾（le se），完全是应该摒弃的糟粕，而教师则只是一些行尸走肉（我的用词不是偏激，而是在读第一章的时候能时时刻刻体会到作者想要表达的这层厌恶之情）。于是乎在这里，我感觉到了文化的差异很明显，也深深地让我感到惊讶，美国中学的教育竟然是这样的？有点不可思议。</p>\n<p>当一个人很坚定的相信自己的某种观点的时候，任何反对的声音都是刺耳的，如果你没有打算“纠正”或者“拯救”他的心意时，那情况就会更糟糕，你可能会选择疏远他。这就是派系的形成，斗争的源头。人类社会一直处于求同存异的阶段，无论基数是几十亿还是几个人，只要“存异”，就有争论。我相信，只有承认这种合理差异存在的人才能更好的认识世界，更好地发掘自然世界的普遍规律（当然了，这一切取决于你所坚持的对象）。还好我没有因为自己的不赞同而放弃阅读，不然肯定就错过了很多精彩的东西。不要过早的宣泄自己的情感，能够忍耐沟通而非固执己见。我们的消化系统决定了我们可以吸收的东西，而食物在人种之间的划分应该是比较模糊的，有绝对的在一个部落可以称之为实物而在另一个国度却根本无法被任何一个人消化的东西吗？我们需要的构造人体的生物物质一样，那么就不要太在意在你饿肚子时候别人贡献出来的晚餐自己是否能消化，吃下去，让消化系统去处理。</p>\n<h2 id=\"享受阅读的乐趣\"><a href=\"#享受阅读的乐趣\" class=\"headerlink\" title=\"享受阅读的乐趣\"></a>享受阅读的乐趣</h2><p>一本好书给人的感觉就是越读越有趣（我们不应该奢望一个健身教练读<cite>《人月神话》</cite>读得津津有味），读书读到舍不得放开手的时候太多了，任何一道符合你口味的菜都能让你垂涎三尺。这不是读者的境界，而是内容本身的精彩。当看到平时不怎么阅读的小伙伴捧起了一本书聚精会神，我们应该惊叹这本书的引力之大，而很多时候我们都走偏了。书籍本身就是我们读书的动力，在我看来，完全没有必要再去寻找其它外力推动。</p>\n<p>那么，我们为什么会感到有趣呢？</p>\n<p>第一，作者的文笔很风趣，写的很生动。说实话，我在念书的时候，完全没有感觉到文言文之中透露了多少的趣味性，时代不同，语言思维不一样，最多只是觉得写得很顺口，对称，用词精炼，辞藻华丽丽的让我发懵。记得有人曾经曰过：可以无知，不可无趣。</p>\n<p>第二，作者讲的太有道理了，特别能引起你的共鸣。共鸣是最能催生惺惺相惜之情，像作者所描述的，欺负书呆子的学生们也就是寻找一种共鸣来安慰自己。每个个体都是满心希望得到认同的，对于和他们持有同样观点的甲乙丙丁自然就会撞击他们的心头小鹿。</p>\n<p>第三，作者提出的东西太闪亮，让人心悦诚服。这一点就有点居高临下的感觉了，让人觉得眼前站着一个高耸入云的巨人，他给我们描述着一个云端的崭新世界，我们怀着敬畏之心，表示感激之情，彻底被打动。</p>\n<p>同时拥有这三点的创作必然是优秀的，其实你应该能猜到的，我觉得这本书就包含了这三方面的趣味性。大部分的技术类书籍，但凡是技术大咖所著，幽默的风格字里行间总是能轻易感受到，难道是领域特定风格（<abbr title=\"Domain Specific Style\">DSS</abbr>）？二次元世界的冷笑话其实也是很符合人情味的嘛，除了有技术背景的之外，感觉趣味不难琢磨。幽默使人强壮，我亦由此共鸣。感受最深的是作者提出来的各个闪闪发光的点，幽默收获笑容，创意引发惊叹。作者提出的很多观点，无不是反其道而行之，这‘其道’更多的是指向被广泛认同的观点，不仅仅如此，作者还提出了很多可行性很高的建议，如果说每一个观点都让人灵光一闪，那我现在估计已经被闪瞎了。我真正感受到一个黑客思想的‘叛逆’。越对抗越有趣。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>我不敢保证如此粗糙大意的我是否多年之后就遗失了它，以下的内容是我对这本书的每一个章节所做的笼统概括，简单归纳。如果捡了芝麻漏了西瓜也不要责怪，因为，这总比什么都没收获要好一些。</p>\n<h3 id=\"《黑客与画家》\"><a href=\"#《黑客与画家》\" class=\"headerlink\" title=\"《黑客与画家》\"></a><cite>《黑客与画家》</cite></h3><h4 id=\"1-为什么书呆子不受欢迎\"><a href=\"#1-为什么书呆子不受欢迎\" class=\"headerlink\" title=\"1. 为什么书呆子不受欢迎\"></a>1. 为什么书呆子不受欢迎</h4><p>作者探索到的原因大致是因为书呆子将精力都花费在了其他地方，无暇顾及或者更确切的说是他们本身并没有想要处理好人际关系的计划。这是在解释黑客的孤僻和高冷吗？不知道是不是黑客的共鸣。</p>\n<h4 id=\"2-黑客与画家\"><a href=\"#2-黑客与画家\" class=\"headerlink\" title=\"2. 黑客与画家\"></a>2. 黑客与画家</h4><p>黑客与画家是作者的人生中的两种职业阶段，但外在分离而内在耦合，他们都属于真正的创作。作者认为对于黑客来说，真正适合创作的途径只有创业，时间自由，方向自由，拥有足够的掌控权以及百分百的精力投资。这可以算是黑客创业成功的先决条件吧，作者谈到成功的另一条件是贴近用户，具备换位思考的能力（很明显，需求调研的出发点就是明白用户想要什么，做什么才能适合用户，这是商业上取得成功的一大要素）。</p>\n<h4 id=\"3-不能说的话\"><a href=\"#3-不能说的话\" class=\"headerlink\" title=\"3. 不能说的话\"></a>3. 不能说的话</h4><p>在不同的国家，不同的种族，沿袭了很多传统，有着诸多禁忌，有很多言论被明令禁止，有很多观点被强制灌输，作者建议我们对每一件事物保持质疑的心态，将自己的信任交给它们，很多时候并不会引发灾难性的后果，但是可能让你与创造走向两条平行线。开创者的奇思妙想往往就是在打破一个常规状态的收获，事实证明，推翻常识的出人意料得构想最容易成功，虽然人们因为固化思维而不容易改变，但是又对新生的事物充满好奇，人是矛盾的结合体。作者在文中给我们提出了很多寻找不能说的话的方法，建议我们仔细思考，用自己的思维去判断所谓的“不能说的话”是否是真的不应该说，保持质疑的态度，保持好奇的心理，而不是懒散得随波逐流。作者更进一步提到，不要尝试与笨蛋辩论：</p>\n<blockquote>\n<p>自由思考比畅所欲言更重要</p>\n</blockquote>\n<h4 id=\"4-良好的坏习惯\"><a href=\"#4-良好的坏习惯\" class=\"headerlink\" title=\"4. 良好的坏习惯\"></a>4. 良好的坏习惯</h4><p>按照作为一个黑客的思想，在计算机网络中，任何的一句斩钉截铁的“不能”都可能引起他们极大的不满，认为是一种挑衅而义愤填膺地去攻破它。作者认为黑客的攻防战在绝大部分场合都是在追求技术上的自由，而这种反抗精神是一种“良好的坏习惯”，反抗过程就是一个推陈出新的过程。</p>\n<h4 id=\"5-另一条路\"><a href=\"#5-另一条路\" class=\"headerlink\" title=\"5. 另一条路\"></a>5. 另一条路</h4><p>在读这本书之前，你必然已经知道了Paul Graham是viaweb的创始人，也就是现如今的Yahoo Store。作为互联网行业的领军人物，他在这里详细描述了互联网行业的一些规律以及一些指导性意见。我想这绝对是互联网创业者的一本必读宝典。</p>\n<h4 id=\"6-如何创造财富\"><a href=\"#6-如何创造财富\" class=\"headerlink\" title=\"6. 如何创造财富\"></a>6. 如何创造财富</h4><p>看到这样的标题，很多人可能眼前一亮，大师要教授致富经了，好像闻到了一股金灿灿，红艳艳的味道（请毫不犹豫地忽视地区差异）。然而，大师其实是来说教的，他会告诉你，财富并不只是金钱，金钱只能用来转移财富的所有权，财富是一切创造出来的对人类有价值的东西。这一章，也是在指导创业者如何去寻找一个正确的方向。</p>\n<h4 id=\"7-关注贫富分化\"><a href=\"#7-关注贫富分化\" class=\"headerlink\" title=\"7. 关注贫富分化\"></a>7. 关注贫富分化</h4><p>在这一章，作者开始公然反对我们政治教科书上的观点（依稀记得我国国情是如此）：缩小贫富差距。作者认为，为什么要缩小贫富差距，政府实在是吃饱了饭没事干。贫富差距应该是合理的，专业领域差异，个人水平高低必将带来贫富差距，政府究竟是打算把每一个人都培育成领域精英从事社会劳作，还是限制大家产出在一个最低水平，或者只是想平均分配？看上去都不是特别合理。</p>\n<h4 id=\"8-防止垃圾邮件的一种方法\"><a href=\"#8-防止垃圾邮件的一种方法\" class=\"headerlink\" title=\"8. 防止垃圾邮件的一种方法\"></a>8. 防止垃圾邮件的一种方法</h4><p>作者分享了一下他关于垃圾邮件过滤器的处理方式以及分析思想。</p>\n<h4 id=\"9-设计者的品味\"><a href=\"#9-设计者的品味\" class=\"headerlink\" title=\"9. 设计者的品味\"></a>9. 设计者的品味</h4><p>“品味只是一种个人喜好”这种说法受到了作者严厉的抨击，因为如果是这样，那么就不存在一种优秀的设计或者说满世界的都是所谓的优秀设计，因为你将决定权交给个人了，更直白说，你将“优秀”的定义交给个人了，到那时候，每个人都可以说“美丽”这个形容词可能天生就是为他们创造的。而事实绝非如此，优秀的设计是存在的，它是大范围内人们对美的一种普遍认同，作者再次对它的一般规律做了精细的概括，详述了一个优秀的设计必然会继承的一些属性。</p>\n<h4 id=\"10-编程语言解析\"><a href=\"#10-编程语言解析\" class=\"headerlink\" title=\"10. 编程语言解析\"></a>10. 编程语言解析</h4><p>作者在这一章似乎相当的收敛，鲜有明确的表达自己的态度，在结束的时候肯定了目前在编程语言世界里百花争鸣的局面。</p>\n<h4 id=\"11-一百年后的编程语言\"><a href=\"#11-一百年后的编程语言\" class=\"headerlink\" title=\"11. 一百年后的编程语言\"></a>11. 一百年后的编程语言</h4><p>这样一个看似畅想的标题，一般人只会以为作者是在想象一百年以后的语言的样子。不错，作者有这样做，但是却不仅仅这样而已。作者认为，编程语言的发展从来都是缓慢的，现在语言的发展进度也不过是上五十年诞生的某些语言的设想，那么按照这个规律演算，在未来的一百年流行起来的语言可能就会出现在我们这个时代，那么还等什么，抓紧时间赶快研究吧。</p>\n<h4 id=\"12-拒绝平庸\"><a href=\"#12-拒绝平庸\" class=\"headerlink\" title=\"12. 拒绝平庸\"></a>12. 拒绝平庸</h4><p>作者提到了自己之所以成功的秘密武器：采用Lisp语言作为他们开始创业时的语言。作者鼓励创业者采用高效的强大的编程语言而将该语言本身的受欢迎程度抛之脑后。对创业公司来说，高效地实现可以为竞争对手设置壁垒，而高效地实现在软件界就很依赖于使用的开发工具的效率。拒绝采用“业界最佳实践”的推荐，拒绝平庸，才是一个创业公司的成才之道。</p>\n<h4 id=\"13-书呆子的复仇\"><a href=\"#13-书呆子的复仇\" class=\"headerlink\" title=\"13. 书呆子的复仇\"></a>13. 书呆子的复仇</h4><p>强调语言选择的重要性。</p>\n<h4 id=\"14-梦寐以求的编程语言\"><a href=\"#14-梦寐以求的编程语言\" class=\"headerlink\" title=\"14. 梦寐以求的编程语言\"></a>14. 梦寐以求的编程语言</h4><p>作者描述了一个完美的编程语言的设计要求（当然了，你可以参考这个设计一百年以后的编程语言）。</p>\n<h4 id=\"15-设计与研究\"><a href=\"#15-设计与研究\" class=\"headerlink\" title=\"15. 设计与研究\"></a>15. 设计与研究</h4><p>更推崇设计。研究更是一种自己关在小黑屋里冥思苦想，处于小片区域集中，整体孤立的状态，而设计的先天性要求需要参与人类的社会活动，需要考虑人的因素，必然考虑到用户，活动的范围要比研究要大的多。作者看样子更愿意被称呼为“设计师”。</p>\n"},{"title":"浏览器事件机制的几个基本概念","url":"tomasran.space/archives/tqX1rLAoV4RgnYJt7iLebA/","content":"<h2 id=\"没有事件，网页玩不转\"><a href=\"#没有事件，网页玩不转\" class=\"headerlink\" title=\"没有事件，网页玩不转\"></a>没有事件，网页玩不转</h2><p>操作一个网页的时候，你的举手投足，一颦一笑时刻都被一个神秘人默默地关注着，你不用感到害怕，他不是一个坏银，恰恰相反，你想要前往的去处，达到的目标，他都会赶在你的前面先去铺路叠桥，不让你遭遇一点儿坎坷。他对于你的需求的重视已经远远超过了对自己生命的爱护，因此他会常常疲惫不堪，心力交瘁，有时甚至临近崩溃的边缘。但只要病魔不夺走他的意识，他都会为了你的需要而奔波忙碌。说着说着，我的眼角不禁为他绽放了感动的泪花。</p>\n<a id=\"more\"></a>\n<p>这个似暗实明的神秘人，就是我们可亲可爱的web浏览器。</p>\n<p>浏览器向我们展现了各色各样的网页，包含大量的交互动作，表单的提交，按钮的点击，窗口的滚动，等等等等。我们不能通过人类的语言和他沟通，让他完成某项工作，因此有了事件机制，构建人机沟通的桥梁。可以说在任何一个图形化界面的应用程序中，乃至图形化操作系统，都是事件响应机制来完成用户希望达到的目的或者期待显示的效果。</p>\n<p>简而言之，在网页中，事件就是告诉浏览器发生了什么事情。浏览器以此为据，给予响应（事件是客户端的一种处理机制，虽然以下以Javascript语言为例，但是并不代表事件机制与Javascript这门语言存在直接联系，联系的建立是依靠客户端来实现的，事件机制本身并不是Javascript语言的内容）。</p>\n<p>浏览器端的事件的处理是执行一段Javascript代码，浏览器端的交互模式的实现实际上是基于javascript的异步事件驱动模型编程。下面是该模型的简单图示：</p>\n<p><img src=\"http://cl.ly/3f263Z09083x/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<p>想要了解javascript机制的全貌吗？我们先从它的基本组成部分说起。</p>\n<h2 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h2><p>命名是一件严肃的事儿。在文学上，望文生义是大忌，而在编程界，我们在命名时就应该做到望文生义（这真的是一种良好的编码规范，足以让你感恩先辈遗福后来，你若傲娇我也没辙）。事件类型的命名，更应该如此，从看上去就应该知道这个事件类型对应了什么样的操作，而不致使人疑惑。</p>\n<p>在Javascript中，定义了一系列具有实际意义的事件类型，比如“click”，定义了单击的事件（注意并不是只针对鼠标单击）；“mouseover”，定义了鼠标移动到某一元素上的事件；“mouseout”，定义了鼠标移出某一元素的事件；等等。</p>\n<p>它们中的每一种都代表了一种不同的操作或者状态。但是兼容性参差不齐，毕竟因为浏览器厂商的复杂局面，我们在面对不同浏览器以及它们的不同版本的时候，使用什么样的事件类型还是得多做考量。你也不用紧张，大多数已经列入标准的常用的事件类型都可以放心的使用。</p>\n<p>这里不去列举每一种事件类型及其含义，具体可以参见 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events\" target=\"_blank\" rel=\"external\">事件类型一览表</a>。</p>\n<p>在事件类型的划分上，除了细到每一种具体的含义之外，从高一点的层次划分，一般可以分为：鼠标事件、键盘事件、触摸屏和移动端设备事件，window事件，dom事件和表单事件等。</p>\n<h2 id=\"事件目标\"><a href=\"#事件目标\" class=\"headerlink\" title=\"事件目标\"></a>事件目标</h2><p>事件目标是发生事件的对象或者是与该事件相关的对象。</p>\n<p>确定了事件类型，我们知道需要响应什么样的事件。但是，网页元素那么多，让每一个元素都响应该事件显然是不合理的。既然如此，我们就需要确定响应事件的目标。它可以是一个button，一个div，一个input框，或者整个文档，事件目标的确定自然依赖于需求。</p>\n<h2 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h2><p>事件处理程序是事件目标在响应指定的事件类型时需要执行的程序。看看如下代码：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">xxx.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e)</span></span> &#123;</span><br><span class=\"line\">  e = e || window.event;</span><br><span class=\"line\">  e.<span class=\"keyword\">target</span> = e.<span class=\"keyword\">target</span> || e.srcElement;</span><br><span class=\"line\">  ... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后面的function声明的函数就是我们的事件处理程序。我们经常会看到以上函数声明，前两句和具体的业务逻辑并没有什么联系，它们的作用是为了解决浏览器兼容性问题。如果要探究其意义的话，我们自然要先弄清楚事件处理函数中传入的参数‘e’代表什么。</p>\n<p>注意，这不是error的简写！而是事件对象。</p>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><p>事件对象是什么？事件对象是与特定信息相关并且包含有关该事件详细信息的对象。<br><br>什么时候产生？当事件触发时生成，并传递给相应的事件处理函数。<br><br>什么时候销毁？当事件处理函数执行完立即销毁。<br></p>\n<p>事件对象包含很多的属性，例如触发这个事件的事件目标 ‘target’，事件的类型 ‘type’ 等等，想要了解事件对象的具体属性可以参见 <a href=\"http://www.w3school.com.cn/jsref/dom_obj_event.asp\" target=\"_blank\" rel=\"external\">W3C Event对象</a>。</p>\n<p>一般情况下，事件对象都会传递给事件处理函数，但总有浏览器别出心裁，例如IE8及其之前版本，它们不会在事件触发时生成一个单独的事件对象传递给事件处理函数，取而代之，它们采用了全局变量的方法，通过绑定在Window对象上的全局变量event来访问事件对象的属性，并且只有在事件处理函数执行的时候才能访问到这个对象，也就是说，window.event在一般情况下是访问不到的（看上去是事件处理函数执行时给全局变量添加了event属性，执行完之后删除，未研究源码，臆测）。因此为了解决浏览器兼容性的问题，就有了上文中的这一段代码：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">e</span> = e || window.event</span><br></pre></td></tr></table></figure>\n<p>事实上，IE中的event对象和其他浏览器的事件对象还有很多的属性差别。例如IE的event对象就没有target这一属性，而它的srcElement与其拥有同样的属性值。这样，也就催生出上文中的第二段代码：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\">e.<span class=\"keyword\">target</span> = e.<span class=\"keyword\">target</span> || e.srcElement</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>以上是Javascript事件机制中的几个基本的概念，到目前为止，我们并没有为它们建立彼此之间的联系，先混个脸熟，之后再介绍具体的运作机制。</p>\n"},{"title":"简洁方便的Python装饰器","url":"tomasran.space/archives/2EtuI1YCnHOf-oLTmf71XQ/","content":"<p>Python装饰器在实际的编码过程中使用非常广泛，它为Python中的函数编写提供了良好的扩展性，在拾获Python装饰器的相关概念、用法之前，我们先简单了解一下Python中函数的特性。</p>\n<h2 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h2><p>在Python中一切即对象。</p>\n<p>函数也不得不遵守Python界的自然法则。我们可以将函数作为参数进行传递。Python中，以自变量为参数的传递都是传递对象的引用。来看下面的例子：</p>\n<a id=\"more\"></a>\n<p><img src=\"http://img.blog.csdn.net/20150923185332086\" alt=\"Python装饰器\"></p>\n<p>这是以函数为参数的一个很简单的例子，参数func是函数的引用，在调用的时候，我们将police作为参数传递进去，由此可见，函数的名称是一个指向函数对象的指针，这样，我们可以将不同的变量指向该函数对象并调用该函数。</p>\n<p><img src=\"http://img.blog.csdn.net/20150923190254642\" alt=\"\"></p>\n<p>thief竟然也成为了policeman！这样的替代在函数调用时依然是完全等价的。因此，我们可以将自己所喜欢的任意名称指向一个函数并能够获得它的所有特征。</p>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>函数可作为参数进行传递是Python装饰器的基础。望文生义在文学艺术的鉴赏上并不是一个很好的习惯，但在计算机界，从字面上便能获取程序的一些设计信息和功能介绍却是每一段优秀代码的良好开端。就如计算机界的各种专业术语也是致力于秉承这优良品质。追求更加语义化。</p>\n<p>这样，我们来分析一下装饰的含义，装饰就是给一个本来存在的东西进行一下外部的修饰，比如首饰，项链，各种化妆品等都是女孩用来锦上添花的装饰（当然也不排除雪中送炭）。Python中的装饰器也是起到了同样的效果：在函数的运行前后，动态扩展函数的功能。</p>\n<p>看一看具体的适用方法：</p>\n<p><strong>1. 使用 “@” 语法糖来装饰函数：</strong></p>\n<p>为了提高程序代码的可读性，以及让装饰器具备自己的鲜明特征，Python中使用 “@” 语法糖来构建函数间的装饰关系。</p>\n<p><img src=\"http://img.blog.csdn.net/20151008223151140\" alt=\"Python装饰器\"></p>\n<p>在Python的交互模式中，不论多行还是单行语句都会在输入结束之后立即运行。Python中的 “@” 语法糖实际上是执行了一个这样的过程：</p>\n<p>police = person(police)</p>\n<p>因为上例中我们定义的person函数并没有返回任何类型的对象，所以police被重新赋值之后是NoneType，这也是为什么再次调用police()会出错的原因。</p>\n<p>那么该如何定义一个合格的装饰器函数呢？我们采用内嵌包装函数来实现。从上面的例子可以分析，我们需要person(police)执行结果返回一个函数，然后将police指向该函数。</p>\n<p><img src=\"http://img.blog.csdn.net/20151009222350193\" alt=\"Python装饰器\"></p>\n<p>我们不难得到，之后调用的police函数实际上是指向了person中的decorate函数。</p>\n<p><strong>2. 装饰带参数的函数：</strong></p>\n<p>上面给出的例子中被装饰函数不带参数，然而在实际应用中，往往被装饰的函数是带有自己的参数的，带参数的函数如何被装饰呢？</p>\n<p><img src=\"http://img.blog.csdn.net/20151009223021036\" alt=\"Python装饰器\"></p>\n<p><code>police(&#39;policewoman&#39;)</code> 的调用和未装饰前的调用方式完全一样，我们只需要向person中的decorate函数的定义中也添加对应的参数就可以了（因为它实际上调用的就是person中的decorate函数）。</p>\n<p>下面给出一个接受任意参数的装饰器例子（python中函数参数的几种形式在这里不做细究）。</p>\n<p><img src=\"http://img.blog.csdn.net/20151009223659007\" alt=\"Python装饰器\"></p>\n<p><strong>3. 装饰器带参数：</strong></p>\n<p>装饰器可以为装饰函数添加一些额外的功能，作为函数本身，装饰器本身有时也需要传递参数，请看下例：</p>\n<p><img src=\"http://img.blog.csdn.net/20151009224907848\" alt=\"Python装饰器\"></p>\n<p>带有参数的装饰器，在定义完成后实际执行了这样一个过程：<code>police = person(&#39;person&#39;)(police)</code>，即先返回了decorate函数，然后执行 <code>decorate(police)</code>，将police重新指向返回的wrapper函数。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>对Python装饰器的应该算是有了一个全貌的把握，原理很简单，应用的时候需要特别注意高阶函数的返回值和参数设置。多留一点心，少制造一些bug。</p>\n"},{"title":"","url":"tomasran.space/404.html","content":"<!doctype html>\n<html lang=\"en\">\n\t<head>\n\t\t<title>404</title>\n\t\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"http://tomasran.space\" homepagename=\"回到我的主页\"></script>\n\t</head>\n\t<body>\n\t</body>\n</html>\n"},{"title":"","url":"tomasran.space/baidu_verify_VX0D4O58yW.html","content":"VX0D4O58yW"},{"title":"about me","url":"tomasran.space/about/index.html","content":"<p><img src=\"http://ww4.sinaimg.cn/mw690/968f956cjw1ean1k3eergj20im0dy79h.jpg\" alt=\"\"></p>\n<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><p><strong>代号：</strong>陶天然<br><strong>年轮：</strong>25<br><strong>产地：</strong>安徽黄山<br><strong>嗜好：</strong>计算机科学与技术<br><strong>微博：</strong>：<a href=\"http://weibo.com/p/1005052525992300/home?from=page_100505&amp;mod=TAB&amp;is_hot=1#place\" target=\"_blank\" rel=\"external\">tomasran的微博</a><br><strong>wechat：</strong>tomasran<br><strong>e-mail：</strong>tomasran@163.com<br><strong>github：</strong><a href=\"https://github.com/tomasran\" target=\"_blank\" rel=\"external\">https://github.com/tomasran</a><br><strong>stackOverflow: </strong><a href=\"http://stackoverflow.com/users/7122482/tomasran\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/users/7122482/tomasran</a></p>\n"},{"title":"link","url":"tomasran.space/link/index.html","content":""},{"title":"categories","url":"tomasran.space/categories/index.html","content":""},{"title":"search","url":"tomasran.space/search/index.html","content":""},{"title":"tag","url":"tomasran.space/tag/index.html","content":""},{"title":"tags","url":"tomasran.space/tags/index.html","content":""}]