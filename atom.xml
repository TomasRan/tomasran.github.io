<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The World of TomasRan</title>
  <subtitle>陶天然的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="tomasran.space/"/>
  <updated>2016-07-02T01:22:39.000Z</updated>
  <id>tomasran.space/</id>
  
  <author>
    <name>TomasRan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关注代码中的圈复杂度</title>
    <link href="tomasran.space/archives/0JIUXRpCu91_D8gPSbCI3g/"/>
    <id>tomasran.space/archives/0JIUXRpCu91_D8gPSbCI3g/</id>
    <published>2016-07-02T00:55:35.000Z</published>
    <updated>2016-07-02T01:22:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;知己知彼，国际惯例先定义&quot;&gt;&lt;a href=&quot;#知己知彼，国际惯例先定义&quot; class=&quot;headerlink&quot; title=&quot;知己知彼，国际惯例先定义&quot;&gt;&lt;/a&gt;知己知彼，国际惯例先定义&lt;/h2&gt;&lt;p&gt;定义自然是很重要的，知己知彼，所以游刃有余。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;圈复杂度（Cyclomatic Complexity）是软件测试的一个衡量标准，代表程序中线性独立的路径的个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;线性独立路径是指程序中至少引进一个新的处理语句集合或一个新条件的任一路径。采用流图的术语，即独立路径必须包含一条在定义路径之前不曾用到的边。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;圈复杂度是能够定量进行计算的。我们借助程序控制流程图来分析一下它的计算方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cl.ly/0Y2y2S300u0y/Snip20160415_2.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;将一个简单的程序控制流程绘图如上，每一个圆圈代表程序的一个执行步骤，命名为‘节点’（命名是为了方便后面的描述）；每一个带方向的箭头表示了该程序的执行路径，命名为‘路径’。可以很清晰地看见程序中存在着循环和分支结构。&lt;/p&gt;
&lt;p&gt;那么接下来就是圈复杂度的计算公式：&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;公式&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：V(G) = &lt;span class=&quot;keyword&quot;&gt;E&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;N&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * P&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;E代表控制流程图的路径数量，N代表节点数量，那么P代表的是什么？它指的是程序的构成组件的个数。而从程序的控制流图来看，直接反映是节点互相是连通的流程图的个数（每一个独立的程序都有自己的控制流图，公式1可以用来整体分析多个独立程序或方法的圈复杂度）。上例中各个节点都是相连通的，因此只有一个独立组件。&lt;/p&gt;
&lt;p&gt;对单个出入口的程序来说，P值始终为1，因此公式可以简写为：&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;公式&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：V(G) = &lt;span class=&quot;keyword&quot;&gt;E&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;N&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; （适用于单个出入口情况）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在介绍另一种情况（做图有王小二过年的气势）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cl.ly/1p462O3A3F06/Snip20160415_3.png&quot; alt=&quot;强连通图&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于这样一个强连通的控制流图（强连通图是指有向图中的每一个节点都有至少一个流入和流出，数学形式的定义更为严谨，可以问 &lt;a href=&quot;http://baike.baidu.com/link?url=2ZynNeGc5lJK8JwOyCpLOk8qjiVZQZKbrcV0RIYCq3CJ8u0imBOyA8ZKDqAHgY5SxCmzMKIYxBCBzLpEL04fwK&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;度娘&lt;/a&gt;），计算它的圈复杂度可以采用公式：&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;公式&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;：V(G) = &lt;span class=&quot;keyword&quot;&gt;E&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;N&lt;/span&gt; + P&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;控制流图中增加了一条从终点到起点的路径，整个流图形成了一个闭环。采用公式是很正确的做法，但是如果懒到不想计算的话，对于这个闭环我们还可以采取其他的方法得到它的圈复杂度，那就是数数在这个闭环中有多少不同的线性独立回路，说的通俗易懂点，就是控制流图中循环圈圈的个数（注意：必须是可循环的圈圈，并且不包含子圈）。一个简单的图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cl.ly/0M100Z2S0M3H/Snip20160416_4.png&quot; alt=&quot;线性独立图示&quot;&gt;&lt;/p&gt;
&lt;p&gt;公式3还有一个听上去很正式的名字叫做 &lt;a href=&quot;https://en.wikipedia.org/wiki/Betti_number&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第一贝蒂数（the first Betti number）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在编程的过程中，通过绘制程序的控制流图来计算圈复杂度，进而将其控制在一个较低水平显然是一件极其麻烦的事儿，这里有更便捷的方法来帮助降低程序圈复杂度，当然，捷径的终点必须和我们想要去的地方一致。Thomas J. McCabe 为我们证明了这一点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个结构化程序只有一个进入点和一个结束点，那么它的圈复杂度等于程序中决策点（分支、条件循环）的个数加 1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这给我们的实际指导就是在编码的过程中尽量减少使用循环和分支结构。&lt;/p&gt;
&lt;p&gt;这个证明已经被推广到单个进入点，多个结束点的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight cos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;公式&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;： V(G) = π - &lt;span class=&quot;keyword&quot;&gt;s&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;π 指的是决策点的个数，s 指的是结束点的个数。&lt;/p&gt;
&lt;p&gt;到这里，我们可以得出一个等式：&lt;/p&gt;
&lt;figure class=&quot;highlight fix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;降低圈复杂度 &lt;/span&gt;=&lt;span class=&quot;string&quot;&gt; 减少分支 + 减少循环&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序判定结构的多少与其复杂度呈正相关，而复杂度的高低和程序的质量呈负相关（判定本身就是一件伤脑经的事儿，至少纯粹是与非的判定中你就要不得不设计两种结果，对于测试来说就要增加测试用例）。我们的目标很明确，减少判定，降低圈复杂度，提高程序质量，坚持“看着舒心，用着放心”的可持续发展道路。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h2&gt;对症下药，如何降低 javascript 中的圈复杂度&lt;/h2&gt;&lt;br&gt;上面的定义和分析已经为我们在任何结构化语言的编码过程中减少圈复杂度指定了统一的大政方针：减少分支和循环的使用，那么接下来，我们就需要考虑具体的落实措施了。&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量尽量初始化。减少undefined和null的出现，可以消除部分场景中的分支判断。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用javascript的对象Object帮助减少分支。javascript对象是一张哈希表，直接寻址寻址速度快，用它来减少分支也能提升代码执行效率。举个锤子：&lt;/p&gt;
  &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a === &lt;span class=&quot;string&quot;&gt;&#39;dog&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a === &lt;span class=&quot;string&quot;&gt;&#39;cat&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a === &lt;span class=&quot;string&quot;&gt;&#39;mice&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a === &lt;span class=&quot;string&quot;&gt;&#39;duck&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a === &lt;span class=&quot;string&quot;&gt;&#39;pig&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大量的 if-else 看上去丑陋不说，让代码的圈复杂度一路飙升，那么利用javascript的对象，我们可以这样改善代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; animals = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&#39;dog&#39;&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&#39;cat&#39;&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&#39;mice&#39;&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&#39;duck&#39;&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&#39;pig&#39;&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;animals[a]();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效率提升，圈复杂度减少，不二选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当定义的函数包含进行分支判断的参数，思考是否可以将路径的选择提前。简单来说，就是判断是否可以交给它的调用函数来选择，甚至交给用户自己去选择。这适用于一部分场景，举个锤子：比如页面上有几个按钮，现在js的处理逻辑是用户点击不同按钮，在js获取点击事件传递过来的参数后判断用户点击了哪一个，然后执行相应路径代码。现在，为了消除js的这个判断过程，我们可以对于不同的按钮绑定不同的点击事件，这样就可以消除js中关于用户究竟点了哪一个的判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多的javascript代码风格检测工具都可以检测程序的圈复杂度，比如 &lt;a href=&quot;https://codeclimate.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code Climate&lt;/a&gt;等等，它们会单独检测每个函数的圈复杂度（单个函数的圈复杂度不包含其内部调用函数的圈复杂度）。对于圈复杂度过高的函数定义自然就会对你采取丑拒的姿态，比较非专业的解决方法是将内部判断部分提取出来重新定义函数，这样可以骗过分析器，但是从根本上来讲是投机取巧万万不可取也。最佳途径自然是优化代码，减少分支、循环的数量。&lt;/p&gt;
&lt;h2 id=&quot;友情推荐，工欲善其事必先利其器&quot;&gt;&lt;a href=&quot;#友情推荐，工欲善其事必先利其器&quot; class=&quot;headerlink&quot; title=&quot;友情推荐，工欲善其事必先利其器&quot;&gt;&lt;/a&gt;友情推荐，工欲善其事必先利其器&lt;/h2&gt;&lt;p&gt;那么，如何去检测javascript代码的圈复杂度呢？画流程图自然不可取，数代码中的循环和分支的个数显然也不是懒惰的程序员喜欢做的（稍微复杂的代码就能让你眼冒金星）。自然去寻找一些好用的工具帮助我们提升效率，这里有两个推荐：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在线检测网站：&lt;a href=&quot;http://www.jscomplexity.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSComplexity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;命令行检测工具：&lt;a href=&quot;https://github.com/jared-stilwell/complexity-report&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;complexity-report&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;知己知彼，国际惯例先定义&quot;&gt;&lt;a href=&quot;#知己知彼，国际惯例先定义&quot; class=&quot;headerlink&quot; title=&quot;知己知彼，国际惯例先定义&quot;&gt;&lt;/a&gt;知己知彼，国际惯例先定义&lt;/h2&gt;&lt;p&gt;定义自然是很重要的，知己知彼，所以游刃有余。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;圈复杂度（Cyclomatic Complexity）是软件测试的一个衡量标准，代表程序中线性独立的路径的个数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Investigation" scheme="tomasran.space/category/Investigation/"/>
    
    
      <category term="圈复杂度" scheme="tomasran.space/tags/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="Cyclomatic Complexity" scheme="tomasran.space/tags/Cyclomatic-Complexity/"/>
    
  </entry>
  
  <entry>
    <title>词法作用域和动态作用域的点点剖析</title>
    <link href="tomasran.space/archives/jQXql7YNdkgCoEzgWHxioA/"/>
    <id>tomasran.space/archives/jQXql7YNdkgCoEzgWHxioA/</id>
    <published>2016-07-01T08:56:19.000Z</published>
    <updated>2016-07-02T01:07:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;作用域和作用域链&quot;&gt;&lt;a href=&quot;#作用域和作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域和作用域链&quot;&gt;&lt;/a&gt;作用域和作用域链&lt;/h2&gt;&lt;p&gt;不同的国家制定不同的法律来依法量刑。但是法律有界限，它们只对自己的国民有着束缚之力。各国的法律只有在自己国土上才有效，才被认可，这个有效范围的限制，就是法律的作用域。&lt;/p&gt;
&lt;p&gt;作用域即是对权限的界定。作用域的主体是不可忽视的，它明确了是对什么事物的权限界定。上面所讲的，法律就是作用域的主体。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;那么什么是作用域链呢？假设现在从地方乡镇到市政府到省政府指定了不完全相同的法律。某人做了一件有违公共道德的事情，地方乡镇发现没有对该罪行制定相应的处罚措施，但是我们可是依法治国、以德治国的国家啊，不能就这样罢休！于是乡镇法院将人犯转移到市级法院，想让市法院依据指定的法律法规对其进行审判，市法院扫了一眼法律法规，也无可奈何，那就交给省法院吧（人犯走了不少路），省法院发现，哎，根据我们的法律法规，他这么做是要处刑的，哈哈，终于可以给这家伙定刑了吧，于是给他定了个xx犯的头衔。&lt;/p&gt;
&lt;p&gt;在这里，各级法院的法律法规就构成了一条法律的作用域链。我们从最底层的法院（靠人犯犯案地点最近的法院）进行向上查找，直到找到明确可以给他量刑的法律，然后名正言顺地把他打入大牢。&lt;/p&gt;
&lt;p&gt;我们可以理解为作用域就是法律制定的时候规定的有效范围，而作用域链是法律执行时候的一系列依据。&lt;/p&gt;
&lt;p&gt;在计算机中也存在着相同的概念，现在我们所要谈论的作用域，是编程语言中标识符的作用域；谈论的作用域链，是程序执行过程中标识符的取值的查找依据。&lt;/p&gt;
&lt;p&gt;因为编程语言设计的差异，目前，针对标识符，存在着两种不同的作用域规则，也就是两种不同的作用域链生成机制，一是词法作用域（Lexical Scoping），二是动态作用域（Dynamic Scoping）。它们规定了标识符（以下都称为变量）在程序中的可访问性。&lt;/p&gt;
&lt;h2 id=&quot;词法作用域&quot;&gt;&lt;a href=&quot;#词法作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域&quot;&gt;&lt;/a&gt;词法作用域&lt;/h2&gt;&lt;p&gt;词法作用域又称静态作用域（Static Scoping），词法作用域是根据编译的阶段进行命名（编译阶段依次经历词法分析、语法分析、语义分析等阶段），意味着变量的作用域在编译的词法分析阶段就已经确定了。&lt;/p&gt;
&lt;p&gt;词法作用域规定变量的作用域链在声明的时候就已经确定，或者说在编译的时候已经确定，在声明它的代码块内部才可以被访问。以Javascript语言为例：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的例子执行的最终结果是输出了字符 “a”、“undefined”，为什么？变量a的声明和函数f的声明都在同一个代码块中，所以在函数f的内部也可以访问到变量a，也就是外部的变量a在函数f内部访问的作用域链上；但是变量b的声明是在函数f的内部，因此不在外部代码块的作用域链上。&lt;/p&gt;
&lt;p&gt;这就是词法作用域指定的规则，需要牢记变量的作用域链是在声明时就已经生成确定。&lt;/p&gt;
&lt;h2 id=&quot;动态作用域&quot;&gt;&lt;a href=&quot;#动态作用域&quot; class=&quot;headerlink&quot; title=&quot;动态作用域&quot;&gt;&lt;/a&gt;动态作用域&lt;/h2&gt;&lt;p&gt;说完了静态作用域，现在可以谈谈它的老对手动态作用域，动态作用域的规则是：变量的作用域链的形成是在代码执行阶段。我们从一个例子说起：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  f1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f2();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码采用的Javascript的语法，执行结果是什么？ 答案是 “a”。再次搬出词法作用域的规则：变量的作用域链是在声明的时候就已经确定。上段代码在声明的时候，f1中的变量a已指向最外层的变量a。因此，当执行f2的时候，f2内部重新声明的变量a，只是开辟了新的内存地址，不会覆盖最外层的变量a。在f2中调用f1，由于f1中的变量a在声明时已经确定指向了最外层的变量a，所以只要最外层的变量a的值不变，它就会输出 “a”。&lt;/p&gt;
&lt;p&gt;这是以上这段代码在静态作用域下的表现。那么现在，我们假设Javascript是采用动态作用域，上述函数的执行结果又会是什么呢？&lt;/p&gt;
&lt;p&gt;鉴于大家恐是无法通过编码去验证这一段代码，我也就只能公布一下正确答案，传递传递思想了（如果想要实践的话可以去接触接触Lisp的早期版本），这一次的输出将会是 “b”。&lt;/p&gt;
&lt;p&gt;动态作用域规则指出变量作用域的确定是在执行过程中。当语句执行到f1中的输出语句时，需要查询变量a的值，此时，动态作用域规则会根据函数的调用栈，从语句所在的函数开始，依次向外直到最外层全局环境，去搜索变量的定义直到找到为止。因此，在不知道具体执行之前，我们是无法直到f1中的变量a到底指向了哪里，这就是动态作用域设定的游戏规则。&lt;/p&gt;
&lt;h2 id=&quot;青梅煮酒论英雄&quot;&gt;&lt;a href=&quot;#青梅煮酒论英雄&quot; class=&quot;headerlink&quot; title=&quot;青梅煮酒论英雄&quot;&gt;&lt;/a&gt;青梅煮酒论英雄&lt;/h2&gt;&lt;p&gt;总结来看，个人还是认为静态作用域的优势明显要强于动态，对于静态作用域，我们可以只通过分析代码文件就能够确定变量的作用域和程序的输出，无论从bug调试、编码逻辑上来看都会轻松不少，增强了程序代码的可维护性。其次，动态作用域在调用的时候动态生成作用域链肯定会影响执行的速度，从性能上来说静态占优。看看Lisp已经成功完成了向静态作用域的华丽丽转型，再看看静态作用域的语言类型压倒性的优势，似乎都足以说明问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域和作用域链&quot;&gt;&lt;a href=&quot;#作用域和作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域和作用域链&quot;&gt;&lt;/a&gt;作用域和作用域链&lt;/h2&gt;&lt;p&gt;不同的国家制定不同的法律来依法量刑。但是法律有界限，它们只对自己的国民有着束缚之力。各国的法律只有在自己国土上才有效，才被认可，这个有效范围的限制，就是法律的作用域。&lt;/p&gt;
&lt;p&gt;作用域即是对权限的界定。作用域的主体是不可忽视的，它明确了是对什么事物的权限界定。上面所讲的，法律就是作用域的主体。&lt;/p&gt;
    
    </summary>
    
      <category term="Investigation" scheme="tomasran.space/category/Investigation/"/>
    
    
      <category term="词法作用域" scheme="tomasran.space/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="动态作用域" scheme="tomasran.space/tags/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="Lexical Scoping" scheme="tomasran.space/tags/Lexical-Scoping/"/>
    
      <category term="Dynamic Scoping" scheme="tomasran.space/tags/Dynamic-Scoping/"/>
    
  </entry>
  
  <entry>
    <title>关于字符集、编码字符集和字符编码</title>
    <link href="tomasran.space/archives/1lYfLLOTOzer67ZuqHJRlg/"/>
    <id>tomasran.space/archives/1lYfLLOTOzer67ZuqHJRlg/</id>
    <published>2016-06-30T08:04:03.000Z</published>
    <updated>2016-06-30T13:33:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;准备好开始&quot;&gt;&lt;a href=&quot;#准备好开始&quot; class=&quot;headerlink&quot; title=&quot;准备好开始&quot;&gt;&lt;/a&gt;准备好开始&lt;/h2&gt;&lt;p&gt;我不是偏执于概念，只是很多时候只有对一个词汇或者术语的定义有着明确的把握之后才会自信地去使用它们。我觉得这不至于是一件钻牛角尖的坏事情，能够清晰地辨别它们或者准确地使用它们至少令自己心里踏实，不会迷惑于其它叙述者的七嘴八舌。&lt;/p&gt;
&lt;p&gt;因此，在比较充分地接触编码这一堆看上去令人头晕脑胀的事情之前，我想有必要先明确几个概念，相信我，这将有助于我们理清思绪。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;字符集&quot;&gt;&lt;a href=&quot;#字符集&quot; class=&quot;headerlink&quot; title=&quot;字符集&quot;&gt;&lt;/a&gt;字符集&lt;/h2&gt;&lt;p&gt;顾名思义，字符集是字符的集合。&lt;/p&gt;
&lt;p&gt;字符是什么？世界上各个国家的语言、符号、表情等都可以视为字符。在计算机界，一个字符是一个单位的字形、类字形单位或符号的基本信息。&lt;/p&gt;
&lt;p&gt;我所要强调的重点，是在计算机中，存在着大量不同的字符集：ASCII字符集、Unicode字符集、ISO字符集等等，它们的集合元素不尽相同，包含的字符有所差别，这和以信仰为主题而诞生的不同宗教、以工作为主题而出现的不同行业别无二致。它们都属于字符集这个大概念，但是集合元素有差别。&lt;/p&gt;
&lt;p&gt;那么为什么会有这种差别呢？作为一个中国人，我想要计算机支持的字符集里包含所有的中文，理所当然；作为一个美国人，我想要计算机支持的字符里包含所有英文字母，无可厚非；又或者只想任性地定义一套火星文，无力吐槽。假设彼此都不想要支持或包含对方的字符，这样就诞生了不同的字符集。因此，不同设计者的设计目标的差异直接导致了字符集的差别。&lt;/p&gt;
&lt;p&gt;为什么不统一一个包罗万象的字符集呢？统一的过程是漫长的，过程中的分歧也是不可避免，不过好在现在我们已经走上了这条路：Unicode字符集。&lt;/p&gt;
&lt;p&gt;字符集只是将一堆字符收集起来，划了个圈子，起了个名。&lt;/p&gt;
&lt;h2 id=&quot;编码字符集&quot;&gt;&lt;a href=&quot;#编码字符集&quot; class=&quot;headerlink&quot; title=&quot;编码字符集&quot;&gt;&lt;/a&gt;编码字符集&lt;/h2&gt;&lt;p&gt;那么，编码字符集是什么？我们现在准备了一个字符集，然后给字符集中的每个字符映射一个抽象的数字，这就是编码字符集。简单的说，就是给字符集中的字符一一编号。&lt;/p&gt;
&lt;p&gt;以下是Unicode字符集的编号，具体可以参见 &lt;a href=&quot;http://unicode-table.com/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unicode字符编码表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o6lqh5p0j.bkt.clouddn.com/unicode%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%A1%A8.png&quot; alt=&quot;Unicode字符编码表&quot;&gt;&lt;/p&gt;
&lt;p&gt;编码字符集建立了字符和数字码的一一映射关系。&lt;/p&gt;
&lt;h2 id=&quot;字符编解码&quot;&gt;&lt;a href=&quot;#字符编解码&quot; class=&quot;headerlink&quot; title=&quot;字符编解码&quot;&gt;&lt;/a&gt;字符编解码&lt;/h2&gt;&lt;p&gt;那么，现在困惑来了，我们常说的字符编码、字符解码是什么？&lt;/p&gt;
&lt;p&gt;编码字符集是将字符集中的字符和数字建立对应关系，构成了一张映射表。它就静静地躺在那里，无声无息，并不会主动去做些什么。而我们则希望计算机在存储、发送和显示字符的时候能得到正确的结果。那么既然字符集本身无能为力，我们就需要写一套规则、一堆代码去主动处理字符的存储、发送和显示。这一步过程就是字符的编码和解码。&lt;/p&gt;
&lt;p&gt;计算机存储、发送的都是二进制流数据，明白这一点很重要。我们的问题就是如何将这些二进制数据流解析成字符，或者如何将字符用二进制数据表示。&lt;/p&gt;
&lt;p&gt;下面就通过ASCII码字符集（所谓的字符编解码，都是针对某个特定的字符集）对应的编解码方案来解释一下这个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o6lqh5p0j.bkt.clouddn.com/AC5133B5-0FDE-4B29-B277-16EB294FDA22.png&quot; alt=&quot;ASCII码表&quot;&gt;&lt;/p&gt;
&lt;p&gt;上表是ASCII码的编码字符集，一张映射表，ASCII码因为字符数量的稀少，用8bit（通常说一个字节，但注意一个字节并不是总等于8bit，只是现在大部分计算机是这样而已）就可以完全表示。&lt;/p&gt;
&lt;p&gt;ASCII码的编码过程很简单，只需要根据以上这张映射表查找到对应的字节，将该字节进行存储就完成了编码过程。例如字符“A”，存储到文件中就是 “01000001”。so easy，不是吗？ASCII码字符编码就是这样简单的查表过程。解码过程也很简单，对二进制数据流按照8bit进行划分，然后也是根据以上的映射表找到对应的字符即可，例如 “0011000001010000”，划分为 “00110000” 和 “01010000”，查表可得依次是“0”、“P”。&lt;/p&gt;
&lt;p&gt;ASCII码字符集的这一套编解码方案简单的人神共愤。稍微复杂的编码方式例如针对Unicode字符集的UTF-8、UTF-16、UTF-32编码后续再论。重点是，现在我们应该能够清楚地区分字符集、编码字符集和字符编码，并且明白一种字符集只有一套编码字符集，但可以有多种字符编码方案。道理显而易见。&lt;/p&gt;
&lt;p&gt;我们通常所说的编码方式就是针对这各种字符集的不同编码方案，当再听到UTF-8，UTF-16，Big5，ISO-8859-1，GB2312等等乱七八糟的编码方式时，可以不用再感到恐慌，而是轻描淡写的一句：“哦，不过是另外一种字符集的另一种编码方式而已”。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备好开始&quot;&gt;&lt;a href=&quot;#准备好开始&quot; class=&quot;headerlink&quot; title=&quot;准备好开始&quot;&gt;&lt;/a&gt;准备好开始&lt;/h2&gt;&lt;p&gt;我不是偏执于概念，只是很多时候只有对一个词汇或者术语的定义有着明确的把握之后才会自信地去使用它们。我觉得这不至于是一件钻牛角尖的坏事情，能够清晰地辨别它们或者准确地使用它们至少令自己心里踏实，不会迷惑于其它叙述者的七嘴八舌。&lt;/p&gt;
&lt;p&gt;因此，在比较充分地接触编码这一堆看上去令人头晕脑胀的事情之前，我想有必要先明确几个概念，相信我，这将有助于我们理清思绪。&lt;/p&gt;
    
    </summary>
    
      <category term="Investigation" scheme="tomasran.space/category/Investigation/"/>
    
    
      <category term="字符集" scheme="tomasran.space/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
      <category term="字符编码" scheme="tomasran.space/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
      <category term="字符解码" scheme="tomasran.space/tags/%E5%AD%97%E7%AC%A6%E8%A7%A3%E7%A0%81/"/>
    
      <category term="ASCII码" scheme="tomasran.space/tags/ASCII%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>黑客与画家的影子</title>
    <link href="tomasran.space/archives/C8ZzMzr8_QosYft0__Wf3A/"/>
    <id>tomasran.space/archives/C8ZzMzr8_QosYft0__Wf3A/</id>
    <published>2016-04-12T14:35:08.000Z</published>
    <updated>2016-07-02T03:13:35.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;让我先做个猜测&quot;&gt;&lt;a href=&quot;#让我先做个猜测&quot; class=&quot;headerlink&quot; title=&quot;让我先做个猜测&quot;&gt;&lt;/a&gt;让我先做个猜测&lt;/h2&gt;&lt;p&gt;一次偶然的凑单，我收获了这本书：《黑客与画家》。一个从来充满神秘色彩的人物，遇见一个喜欢沉浸于自我陶醉的角色，他们能摩擦出怎样的火花？&lt;/p&gt;
&lt;p&gt;我企图将自己装扮成作者，强行使用小学语文老师传授给我们的移魂大法，无奈作者离我太遥远，远在那我功力遥不可及的地方，我只能就拍着脑门瞎蒙。有一句网红，叫做不喜勿喷，但是我觉得如果实在不喜的话喷喷也无妨，毕竟我只是在瞎蒙，造谣犯法，而瞎蒙和造谣毕竟也没什么区别。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我用我的榆木脑袋在想，作者可能是想表达这两者之间的相通之处吧：他们都属于艺术创作的范畴，绘画是艺术，编程也是艺术。否则，若只是这两者的同台竞技该让多少人摸不着头脑（那样的情况往往是走向两个极端：若非内容的高深即是表达的拙劣）。&lt;/p&gt;
&lt;p&gt;恩，我觉得想的中规中矩，但是像我这种发育健全、有血有肉的鸡蛋，号称鸡蛋中的霸主，从自身的高内涵之中挑出一两根骨头出来也不是什么难事。&lt;/p&gt;
&lt;p&gt;想想作为一只鸡蛋还是得低调，不要总尝试去碰壁，更何况我是鸡蛋中的霸主，于是乎还是决定言归正传聊聊这本书吧。&lt;/p&gt;
&lt;h2 id=&quot;吃下去，交给消化系统去处理&quot;&gt;&lt;a href=&quot;#吃下去，交给消化系统去处理&quot; class=&quot;headerlink&quot; title=&quot;吃下去，交给消化系统去处理&quot;&gt;&lt;/a&gt;吃下去，交给消化系统去处理&lt;/h2&gt;&lt;p&gt;看完人物介绍，Paul Graham，viaweb的创始人，青年时代就热爱上了编程，中学时喜欢写小说（原创小说的确是一个保持创意的好点子，环境自由，人物、情节设定肆意妄为，只要写的一身正气，不给一些吃饱了饭没事干的家伙留下小辫子，完全是属于自己的地盘。作家和灵感从来是互为伯乐的嘛），而后大学主修的是哲学，研究生阶段却又‘跳槽’去主攻人工智能，博士毕业之后，他竟又出人意料地去报班美术，开始学习了绘画甚至之后以此为业。&lt;/p&gt;
&lt;p&gt;这样的人生经历，其实不能说算是有很多离奇的色彩，体现出来更多的，是一种选择上的自由（在某些软件环境里，程式般的生活让每一个表达式都觉得自己生来应该遵守某个规则，运行的上下文制定了稳固的秩序，让它们觉得一旦破坏了这种秩序便会导致全局的瘫痪而且修复无望。规则和威吓限制了自由程式的发展）。我觉得他是根据自己的喜好在过着生活，如果不是后来为了生活费而又转向编程这一项工作，可能绘画领域会多一位大师，不过鱼与熊掌不可兼得的道理应该是没有种族限制的，还是庆幸他在程序员界走了一遭，为我们沉淀了不少好东西。&lt;/p&gt;
&lt;p&gt;读完介绍，我觉得我可能要抱着一丝丝崇拜之心去读他的作品了，恭敬地掀开了第一章。&lt;/p&gt;
&lt;p&gt;说实话，第一章并没有给我带来太多好感，读着读着心情就郁闷了，感觉似乎是一个初高中时代遭受过不公平待遇的孩子在他的往事回忆录中的一种宣泄。作者已经将学校的教育体制黑的体无完肤了，在他眼中可以直接说学校其实是一种毫无必要存在的垃圾（le se），完全是应该摒弃的糟粕，而教师则只是一些行尸走肉（我的用词不是偏激，而是在读第一章的时候能时时刻刻体会到作者想要表达的这层厌恶之情）。于是乎在这里，我感觉到了文化的差异很明显，也深深地让我感到惊讶，美国中学的教育竟然是这样的？有点不可思议。&lt;/p&gt;
&lt;p&gt;当一个人很坚定的相信自己的某种观点的时候，任何反对的声音都是刺耳的，如果你没有打算“纠正”或者“拯救”他的心意时，那情况就会更糟糕，你可能会选择疏远他。这就是派系的形成，斗争的源头。人类社会一直处于求同存异的阶段，无论基数是几十亿还是几个人，只要“存异”，就有争论。我相信，只有承认这种合理差异存在的人才能更好的认识世界，更好地发掘自然世界的普遍规律（当然了，这一切取决于你所坚持的对象）。还好我没有因为自己的不赞同而放弃阅读，不然肯定就错过了很多精彩的东西。不要过早的宣泄自己的情感，能够忍耐沟通而非固执己见。我们的消化系统决定了我们可以吸收的东西，而食物在人种之间的划分应该是比较模糊的，有绝对的在一个部落可以称之为实物而在另一个国度却根本无法被任何一个人消化的东西吗？我们需要的构造人体的生物物质一样，那么就不要太在意在你饿肚子时候别人贡献出来的晚餐自己是否能消化，吃下去，让消化系统去处理。&lt;/p&gt;
&lt;h2 id=&quot;享受阅读的乐趣&quot;&gt;&lt;a href=&quot;#享受阅读的乐趣&quot; class=&quot;headerlink&quot; title=&quot;享受阅读的乐趣&quot;&gt;&lt;/a&gt;享受阅读的乐趣&lt;/h2&gt;&lt;p&gt;一本好书给人的感觉就是越读越有趣（我们不应该奢望一个健身教练读&lt;cite&gt;《人月神话》&lt;/cite&gt;读得津津有味），读书读到舍不得放开手的时候太多了，任何一道符合你口味的菜都能让你垂涎三尺。这不是读者的境界，而是内容本身的精彩。当看到平时不怎么阅读的小伙伴捧起了一本书聚精会神，我们应该惊叹这本书的引力之大，而很多时候我们都走偏了。书籍本身就是我们读书的动力，在我看来，完全没有必要再去寻找其它外力推动。&lt;/p&gt;
&lt;p&gt;那么，我们为什么会感到有趣呢？&lt;/p&gt;
&lt;p&gt;第一，作者的文笔很风趣，写的很生动。说实话，我在念书的时候，完全没有感觉到文言文之中透露了多少的趣味性，时代不同，语言思维不一样，最多只是觉得写得很顺口，对称，用词精炼，辞藻华丽丽的让我发懵。记得有人曾经曰过：可以无知，不可无趣。&lt;/p&gt;
&lt;p&gt;第二，作者讲的太有道理了，特别能引起你的共鸣。共鸣是最能催生惺惺相惜之情，像作者所描述的，欺负书呆子的学生们也就是寻找一种共鸣来安慰自己。每个个体都是满心希望得到认同的，对于和他们持有同样观点的甲乙丙丁自然就会撞击他们的心头小鹿。&lt;/p&gt;
&lt;p&gt;第三，作者提出的东西太闪亮，让人心悦诚服。这一点就有点居高临下的感觉了，让人觉得眼前站着一个高耸入云的巨人，他给我们描述着一个云端的崭新世界，我们怀着敬畏之心，表示感激之情，彻底被打动。&lt;/p&gt;
&lt;p&gt;同时拥有这三点的创作必然是优秀的，其实你应该能猜到的，我觉得这本书就包含了这三方面的趣味性。大部分的技术类书籍，但凡是技术大咖所著，幽默的风格字里行间总是能轻易感受到，难道是领域特定风格（&lt;abbr title=&quot;Domain Specific Style&quot;&gt;DSS&lt;/abbr&gt;）？二次元世界的冷笑话其实也是很符合人情味的嘛，除了有技术背景的之外，感觉趣味不难琢磨。幽默使人强壮，我亦由此共鸣。感受最深的是作者提出来的各个闪闪发光的点，幽默收获笑容，创意引发惊叹。作者提出的很多观点，无不是反其道而行之，这‘其道’更多的是指向被广泛认同的观点，不仅仅如此，作者还提出了很多可行性很高的建议，如果说每一个观点都让人灵光一闪，那我现在估计已经被闪瞎了。我真正感受到一个黑客思想的‘叛逆’。越对抗越有趣。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;我不敢保证如此粗糙大意的我是否多年之后就遗失了它，以下的内容是我对这本书的每一个章节所做的笼统概括，简单归纳。如果捡了芝麻漏了西瓜也不要责怪，因为，这总比什么都没收获要好一些。&lt;/p&gt;
&lt;p&gt;###&lt;cite&gt;《黑客与画家》&lt;/cite&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-为什么书呆子不受欢迎&quot;&gt;&lt;a href=&quot;#1-为什么书呆子不受欢迎&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么书呆子不受欢迎&quot;&gt;&lt;/a&gt;1. 为什么书呆子不受欢迎&lt;/h4&gt;&lt;p&gt;作者探索到的原因大致是因为书呆子将精力都花费在了其他地方，无暇顾及或者更确切的说是他们本身并没有想要处理好人际关系的计划。这是在解释黑客的孤僻和高冷吗？不知道是不是黑客的共鸣。&lt;/p&gt;
&lt;h4 id=&quot;2-黑客与画家&quot;&gt;&lt;a href=&quot;#2-黑客与画家&quot; class=&quot;headerlink&quot; title=&quot;2. 黑客与画家&quot;&gt;&lt;/a&gt;2. 黑客与画家&lt;/h4&gt;&lt;p&gt;黑客与画家是作者的人生中的两种职业阶段，但外在分离而内在耦合，他们都属于真正的创作。作者认为对于黑客来说，真正适合创作的途径只有创业，时间自由，方向自由，拥有足够的掌控权以及百分百的精力投资。这可以算是黑客创业成功的先决条件吧，作者谈到成功的另一条件是贴近用户，具备换位思考的能力（很明显，需求调研的出发点就是明白用户想要什么，做什么才能适合用户，这是商业上取得成功的一大要素）。&lt;/p&gt;
&lt;h4 id=&quot;3-不能说的话&quot;&gt;&lt;a href=&quot;#3-不能说的话&quot; class=&quot;headerlink&quot; title=&quot;3. 不能说的话&quot;&gt;&lt;/a&gt;3. 不能说的话&lt;/h4&gt;&lt;p&gt;在不同的国家，不同的种族，沿袭了很多传统，有着诸多禁忌，有很多言论被明令禁止，有很多观点被强制灌输，作者建议我们对每一件事物保持质疑的心态，将自己的信任交给它们，很多时候并不会引发灾难性的后果，但是可能让你与创造走向两条平行线。开创者的奇思妙想往往就是在打破一个常规状态的收获，事实证明，推翻常识的出人意料得构想最容易成功，虽然人们因为固化思维而不容易改变，但是又对新生的事物充满好奇，人是矛盾的结合体。作者在文中给我们提出了很多寻找不能说的话的方法，建议我们仔细思考，用自己的思维去判断所谓的“不能说的话”是否是真的不应该说，保持质疑的态度，保持好奇的心理，而不是懒散得随波逐流。作者更进一步提到，不要尝试与笨蛋辩论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自由思考比畅所欲言更重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;4-良好的坏习惯&quot;&gt;&lt;a href=&quot;#4-良好的坏习惯&quot; class=&quot;headerlink&quot; title=&quot;4. 良好的坏习惯&quot;&gt;&lt;/a&gt;4. 良好的坏习惯&lt;/h4&gt;&lt;p&gt;按照作为一个黑客的思想，在计算机网络中，任何的一句斩钉截铁的“不能”都可能引起他们极大的不满，认为是一种挑衅而义愤填膺地去攻破它。作者认为黑客的攻防战在绝大部分场合都是在追求技术上的自由，而这种反抗精神是一种“良好的坏习惯”，反抗过程就是一个推陈出新的过程。&lt;/p&gt;
&lt;h4 id=&quot;5-另一条路&quot;&gt;&lt;a href=&quot;#5-另一条路&quot; class=&quot;headerlink&quot; title=&quot;5. 另一条路&quot;&gt;&lt;/a&gt;5. 另一条路&lt;/h4&gt;&lt;p&gt;在读这本书之前，你必然已经知道了Paul Graham是viaweb的创始人，也就是现如今的Yahoo Store。作为互联网行业的领军人物，他在这里详细描述了互联网行业的一些规律以及一些指导性意见。我想这绝对是互联网创业者的一本必读宝典。&lt;/p&gt;
&lt;h4 id=&quot;6-如何创造财富&quot;&gt;&lt;a href=&quot;#6-如何创造财富&quot; class=&quot;headerlink&quot; title=&quot;6. 如何创造财富&quot;&gt;&lt;/a&gt;6. 如何创造财富&lt;/h4&gt;&lt;p&gt;看到这样的标题，很多人可能眼前一亮，大师要教授致富经了，好像闻到了一股金灿灿，红艳艳的味道（请毫不犹豫地忽视地区差异）。然而，大师其实是来说教的，他会告诉你，财富并不只是金钱，金钱只能用来转移财富的所有权，财富是一切创造出来的对人类有价值的东西。这一章，也是在指导创业者如何去寻找一个正确的方向。&lt;/p&gt;
&lt;h4 id=&quot;7-关注贫富分化&quot;&gt;&lt;a href=&quot;#7-关注贫富分化&quot; class=&quot;headerlink&quot; title=&quot;7. 关注贫富分化&quot;&gt;&lt;/a&gt;7. 关注贫富分化&lt;/h4&gt;&lt;p&gt;在这一章，作者开始公然反对我们政治教科书上的观点（依稀记得我国国情是如此）：缩小贫富差距。作者认为，为什么要缩小贫富差距，政府实在是吃饱了饭没事干。贫富差距应该是合理的，专业领域差异，个人水平高低必将带来贫富差距，政府究竟是打算把每一个人都培育成领域精英从事社会劳作，还是限制大家产出在一个最低水平，或者只是想平均分配？看上去都不是特别合理。&lt;/p&gt;
&lt;h4 id=&quot;8-防止垃圾邮件的一种方法&quot;&gt;&lt;a href=&quot;#8-防止垃圾邮件的一种方法&quot; class=&quot;headerlink&quot; title=&quot;8. 防止垃圾邮件的一种方法&quot;&gt;&lt;/a&gt;8. 防止垃圾邮件的一种方法&lt;/h4&gt;&lt;p&gt;作者分享了一下他关于垃圾邮件过滤器的处理方式以及分析思想。&lt;/p&gt;
&lt;h4 id=&quot;9-设计者的品味&quot;&gt;&lt;a href=&quot;#9-设计者的品味&quot; class=&quot;headerlink&quot; title=&quot;9. 设计者的品味&quot;&gt;&lt;/a&gt;9. 设计者的品味&lt;/h4&gt;&lt;p&gt;“品味只是一种个人喜好”这种说法受到了作者严厉的抨击，因为如果是这样，那么就不存在一种优秀的设计或者说满世界的都是所谓的优秀设计，因为你将决定权交给个人了，更直白说，你将“优秀”的定义交给个人了，到那时候，每个人都可以说“美丽”这个形容词可能天生就是为他们创造的。而事实绝非如此，优秀的设计是存在的，它是大范围内人们对美的一种普遍认同，作者再次对它的一般规律做了精细的概括，详述了一个优秀的设计必然会继承的一些属性。&lt;/p&gt;
&lt;h4 id=&quot;10-编程语言解析&quot;&gt;&lt;a href=&quot;#10-编程语言解析&quot; class=&quot;headerlink&quot; title=&quot;10. 编程语言解析&quot;&gt;&lt;/a&gt;10. 编程语言解析&lt;/h4&gt;&lt;p&gt;作者在这一章似乎相当的收敛，鲜有明确的表达自己的态度，在结束的时候肯定了目前在编程语言世界里百花争鸣的局面。&lt;/p&gt;
&lt;h4 id=&quot;11-一百年后的编程语言&quot;&gt;&lt;a href=&quot;#11-一百年后的编程语言&quot; class=&quot;headerlink&quot; title=&quot;11. 一百年后的编程语言&quot;&gt;&lt;/a&gt;11. 一百年后的编程语言&lt;/h4&gt;&lt;p&gt;这样一个看似畅想的标题，一般人只会以为作者是在想象一百年以后的语言的样子。不错，作者有这样做，但是却不仅仅这样而已。作者认为，编程语言的发展从来都是缓慢的，现在语言的发展进度也不过是上五十年诞生的某些语言的设想，那么按照这个规律演算，在未来的一百年流行起来的语言可能就会出现在我们这个时代，那么还等什么，抓紧时间赶快研究吧。&lt;/p&gt;
&lt;h4 id=&quot;12-拒绝平庸&quot;&gt;&lt;a href=&quot;#12-拒绝平庸&quot; class=&quot;headerlink&quot; title=&quot;12. 拒绝平庸&quot;&gt;&lt;/a&gt;12. 拒绝平庸&lt;/h4&gt;&lt;p&gt;作者提到了自己之所以成功的秘密武器：采用Lisp语言作为他们开始创业时的语言。作者鼓励创业者采用高效的强大的编程语言而将该语言本身的受欢迎程度抛之脑后。对创业公司来说，高效地实现可以为竞争对手设置壁垒，而高效地实现在软件界就很依赖于使用的开发工具的效率。拒绝采用“业界最佳实践”的推荐，拒绝平庸，才是一个创业公司的成才之道。&lt;/p&gt;
&lt;h4 id=&quot;13-书呆子的复仇&quot;&gt;&lt;a href=&quot;#13-书呆子的复仇&quot; class=&quot;headerlink&quot; title=&quot;13. 书呆子的复仇&quot;&gt;&lt;/a&gt;13. 书呆子的复仇&lt;/h4&gt;&lt;p&gt;强调语言选择的重要性。&lt;/p&gt;
&lt;h4 id=&quot;14-梦寐以求的编程语言&quot;&gt;&lt;a href=&quot;#14-梦寐以求的编程语言&quot; class=&quot;headerlink&quot; title=&quot;14. 梦寐以求的编程语言&quot;&gt;&lt;/a&gt;14. 梦寐以求的编程语言&lt;/h4&gt;&lt;p&gt;作者描述了一个完美的编程语言的设计要求（当然了，你可以参考这个设计一百年以后的编程语言）。&lt;/p&gt;
&lt;h4 id=&quot;15-设计与研究&quot;&gt;&lt;a href=&quot;#15-设计与研究&quot; class=&quot;headerlink&quot; title=&quot;15. 设计与研究&quot;&gt;&lt;/a&gt;15. 设计与研究&lt;/h4&gt;&lt;p&gt;更推崇设计。研究更是一种自己关在小黑屋里冥思苦想，处于小片区域集中，整体孤立的状态，而设计的先天性要求需要参与人类的社会活动，需要考虑人的因素，必然考虑到用户，活动的范围要比研究要大的多。作者看样子更愿意被称呼为“设计师”。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;让我先做个猜测&quot;&gt;&lt;a href=&quot;#让我先做个猜测&quot; class=&quot;headerlink&quot; title=&quot;让我先做个猜测&quot;&gt;&lt;/a&gt;让我先做个猜测&lt;/h2&gt;&lt;p&gt;一次偶然的凑单，我收获了这本书：《黑客与画家》。一个从来充满神秘色彩的人物，遇见一个喜欢沉浸于自我陶醉的角色，他们能摩擦出怎样的火花？&lt;/p&gt;
&lt;p&gt;我企图将自己装扮成作者，强行使用小学语文老师传授给我们的移魂大法，无奈作者离我太遥远，远在那我功力遥不可及的地方，我只能就拍着脑门瞎蒙。有一句网红，叫做不喜勿喷，但是我觉得如果实在不喜的话喷喷也无妨，毕竟我只是在瞎蒙，造谣犯法，而瞎蒙和造谣毕竟也没什么区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Impression" scheme="tomasran.space/category/Impression/"/>
    
    
      <category term="黑客与画家" scheme="tomasran.space/tags/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器事件机制的几个基本概念</title>
    <link href="tomasran.space/archives/tqX1rLAoV4RgnYJt7iLebA/"/>
    <id>tomasran.space/archives/tqX1rLAoV4RgnYJt7iLebA/</id>
    <published>2016-03-31T16:30:38.000Z</published>
    <updated>2016-07-04T16:32:45.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;没有事件，网页玩不转&quot;&gt;&lt;a href=&quot;#没有事件，网页玩不转&quot; class=&quot;headerlink&quot; title=&quot;没有事件，网页玩不转&quot;&gt;&lt;/a&gt;没有事件，网页玩不转&lt;/h2&gt;&lt;p&gt;操作一个网页的时候，你的举手投足，一颦一笑时刻都被一个神秘人默默地关注着，你不用感到害怕，他不是一个坏银，恰恰相反，你想要前往的去处，达到的目标，他都会赶在你的前面先去铺路叠桥，不让你遭遇一点儿坎坷。他对于你的需求的重视已经远远超过了对自己生命的爱护，因此他会常常疲惫不堪，心力交瘁，有时甚至临近崩溃的边缘。但只要病魔不夺走他的意识，他都会为了你的需要而奔波忙碌。说着说着，我的眼角不禁为他绽放了感动的泪花。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个似暗实明的神秘人，就是我们可亲可爱的web浏览器。&lt;/p&gt;
&lt;p&gt;浏览器向我们展现了各色各样的网页，包含大量的交互动作，表单的提交，按钮的点击，窗口的滚动，等等等等。我们不能通过人类的语言和他沟通，让他完成某项工作，因此有了事件机制，构建人机沟通的桥梁。可以说在任何一个图形化界面的应用程序中，乃至图形化操作系统，都是事件响应机制来完成用户希望达到的目的或者期待显示的效果。&lt;/p&gt;
&lt;p&gt;简而言之，在网页中，事件就是告诉浏览器发生了什么事情。浏览器以此为据，给予响应（事件是客户端的一种处理机制，虽然以下以Javascript语言为例，但是并不代表事件机制与Javascript这门语言存在直接联系，联系的建立是依靠客户端来实现的，事件机制本身并不是Javascript语言的内容）。&lt;/p&gt;
&lt;p&gt;浏览器端的事件的处理是执行一段Javascript代码，浏览器端的交互模式的实现实际上是基于javascript的异步事件驱动模型编程。下面是该模型的简单图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cl.ly/3f263Z09083x/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;想要了解javascript机制的全貌吗？我们先从它的基本组成部分说起。&lt;/p&gt;
&lt;h2 id=&quot;事件类型&quot;&gt;&lt;a href=&quot;#事件类型&quot; class=&quot;headerlink&quot; title=&quot;事件类型&quot;&gt;&lt;/a&gt;事件类型&lt;/h2&gt;&lt;p&gt;命名是一件严肃的事儿。在文学上，望文生义是大忌，而在编程界，我们在命名时就应该做到望文生义（这真的是一种良好的编码规范，足以让你感恩先辈遗福后来，你若傲娇我也没辙）。事件类型的命名，更应该如此，从看上去就应该知道这个事件类型对应了什么样的操作，而不致使人疑惑。&lt;/p&gt;
&lt;p&gt;在Javascript中，定义了一系列具有实际意义的事件类型，比如“click”，定义了单击的事件（注意并不是只针对鼠标单击）；“mouseover”，定义了鼠标移动到某一元素上的事件；“mouseout”，定义了鼠标移出某一元素的事件；等等。&lt;/p&gt;
&lt;p&gt;它们中的每一种都代表了一种不同的操作或者状态。但是兼容性参差不齐，毕竟因为浏览器厂商的复杂局面，我们在面对不同浏览器以及它们的不同版本的时候，使用什么样的事件类型还是得多做考量。你也不用紧张，大多数已经列入标准的常用的事件类型都可以放心的使用。&lt;/p&gt;
&lt;p&gt;这里不去列举每一种事件类型及其含义，具体可以参见 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;事件类型一览表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在事件类型的划分上，除了细到每一种具体的含义之外，从高一点的层次划分，一般可以分为：鼠标事件、键盘事件、触摸屏和移动端设备事件，window事件，dom事件和表单事件等。&lt;/p&gt;
&lt;h2 id=&quot;事件目标&quot;&gt;&lt;a href=&quot;#事件目标&quot; class=&quot;headerlink&quot; title=&quot;事件目标&quot;&gt;&lt;/a&gt;事件目标&lt;/h2&gt;&lt;p&gt;事件目标是发生事件的对象或者是与该事件相关的对象。&lt;/p&gt;
&lt;p&gt;确定了事件类型，我们知道需要响应什么样的事件。但是，网页元素那么多，让每一个元素都响应该事件显然是不合理的。既然如此，我们就需要确定响应事件的目标。它可以是一个button，一个div，一个input框，或者整个文档，事件目标的确定自然依赖于需求。&lt;/p&gt;
&lt;h2 id=&quot;事件处理程序&quot;&gt;&lt;a href=&quot;#事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;事件处理程序&quot;&gt;&lt;/a&gt;事件处理程序&lt;/h2&gt;&lt;p&gt;事件处理程序是事件目标在响应指定的事件类型时需要执行的程序。看看如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xxx.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  e = e || window.event;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  e.&lt;span class=&quot;keyword&quot;&gt;target&lt;/span&gt; = e.&lt;span class=&quot;keyword&quot;&gt;target&lt;/span&gt; || e.srcElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后面的function声明的函数就是我们的事件处理程序。我们经常会看到以上函数声明，前两句和具体的业务逻辑并没有什么联系，它们的作用是为了解决浏览器兼容性问题。如果要探究其意义的话，我们自然要先弄清楚事件处理函数中传入的参数‘e’代表什么。&lt;/p&gt;
&lt;p&gt;注意，这不是error的简写！而是事件对象。&lt;/p&gt;
&lt;h2 id=&quot;事件对象&quot;&gt;&lt;a href=&quot;#事件对象&quot; class=&quot;headerlink&quot; title=&quot;事件对象&quot;&gt;&lt;/a&gt;事件对象&lt;/h2&gt;&lt;p&gt;事件对象是什么？事件对象是与特定信息相关并且包含有关该事件详细信息的对象。&lt;br&gt;&lt;br&gt;什么时候产生？当事件触发时生成，并传递给相应的事件处理函数。&lt;br&gt;&lt;br&gt;什么时候销毁？当事件处理函数执行完立即销毁。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;事件对象包含很多的属性，例如触发这个事件的事件目标 ‘target’，事件的类型 ‘type’ 等等，想要了解事件对象的具体属性可以参见 &lt;a href=&quot;http://www.w3school.com.cn/jsref/dom_obj_event.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;W3C Event对象&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一般情况下，事件对象都会传递给事件处理函数，但总有浏览器别出心裁，例如IE8及其之前版本，它们不会在事件触发时生成一个单独的事件对象传递给事件处理函数，取而代之，它们采用了全局变量的方法，通过绑定在Window对象上的全局变量event来访问事件对象的属性，并且只有在事件处理函数执行的时候才能访问到这个对象，也就是说，window.event在一般情况下是访问不到的（看上去是事件处理函数执行时给全局变量添加了event属性，执行完之后删除，未研究源码，臆测）。因此为了解决浏览器兼容性的问题，就有了上文中的这一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;e&lt;/span&gt; = e || window.event&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上，IE中的event对象和其他浏览器的事件对象还有很多的属性差别。例如IE的event对象就没有target这一属性，而它的srcElement与其拥有同样的属性值。这样，也就催生出上文中的第二段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;e.&lt;span class=&quot;keyword&quot;&gt;target&lt;/span&gt; = e.&lt;span class=&quot;keyword&quot;&gt;target&lt;/span&gt; || e.srcElement&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;以上是Javascript事件机制中的几个基本的概念，到目前为止，我们并没有为它们建立彼此之间的联系，先混个脸熟，之后再介绍具体的运作机制。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;没有事件，网页玩不转&quot;&gt;&lt;a href=&quot;#没有事件，网页玩不转&quot; class=&quot;headerlink&quot; title=&quot;没有事件，网页玩不转&quot;&gt;&lt;/a&gt;没有事件，网页玩不转&lt;/h2&gt;&lt;p&gt;操作一个网页的时候，你的举手投足，一颦一笑时刻都被一个神秘人默默地关注着，你不用感到害怕，他不是一个坏银，恰恰相反，你想要前往的去处，达到的目标，他都会赶在你的前面先去铺路叠桥，不让你遭遇一点儿坎坷。他对于你的需求的重视已经远远超过了对自己生命的爱护，因此他会常常疲惫不堪，心力交瘁，有时甚至临近崩溃的边缘。但只要病魔不夺走他的意识，他都会为了你的需要而奔波忙碌。说着说着，我的眼角不禁为他绽放了感动的泪花。&lt;/p&gt;
    
    </summary>
    
      <category term="client-side-programming" scheme="tomasran.space/category/client-side-programming/"/>
    
    
      <category term="事件类型" scheme="tomasran.space/tags/%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="事件目标" scheme="tomasran.space/tags/%E4%BA%8B%E4%BB%B6%E7%9B%AE%E6%A0%87/"/>
    
      <category term="事件对象" scheme="tomasran.space/tags/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="事件处理程序" scheme="tomasran.space/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简洁方便的Python装饰器</title>
    <link href="tomasran.space/archives/2EtuI1YCnHOf-oLTmf71XQ/"/>
    <id>tomasran.space/archives/2EtuI1YCnHOf-oLTmf71XQ/</id>
    <published>2015-09-23T14:36:12.000Z</published>
    <updated>2016-06-30T14:40:27.000Z</updated>
    
    <content type="html">&lt;p&gt;Python装饰器在实际的编码过程中使用非常广泛，它为Python中的函数编写提供了良好的扩展性，在拾获Python装饰器的相关概念、用法之前，我们先简单了解一下Python中函数的特性。&lt;/p&gt;
&lt;h2 id=&quot;函数对象&quot;&gt;&lt;a href=&quot;#函数对象&quot; class=&quot;headerlink&quot; title=&quot;函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h2&gt;&lt;p&gt;在Python中一切即对象。&lt;/p&gt;
&lt;p&gt;函数也不得不遵守Python界的自然法则。我们可以将函数作为参数进行传递。Python中，以自变量为参数的传递都是传递对象的引用。来看下面的例子：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150923185332086&quot; alt=&quot;Python装饰器&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是以函数为参数的一个很简单的例子，参数func是函数的引用，在调用的时候，我们将police作为参数传递进去，由此可见，函数的名称是一个指向函数对象的指针，这样，我们可以将不同的变量指向该函数对象并调用该函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150923190254642&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;thief竟然也成为了policeman！这样的替代在函数调用时依然是完全等价的。因此，我们可以将自己所喜欢的任意名称指向一个函数并能够获得它的所有特征。&lt;/p&gt;
&lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;p&gt;函数可作为参数进行传递是Python装饰器的基础。望文生义在文学艺术的鉴赏上并不是一个很好的习惯，但在计算机界，从字面上便能获取程序的一些设计信息和功能介绍却是每一段优秀代码的良好开端。就如计算机界的各种专业术语也是致力于秉承这优良品质。追求更加语义化。&lt;/p&gt;
&lt;p&gt;这样，我们来分析一下装饰的含义，装饰就是给一个本来存在的东西进行一下外部的修饰，比如首饰，项链，各种化妆品等都是女孩用来锦上添花的装饰（当然也不排除雪中送炭）。Python中的装饰器也是起到了同样的效果：在函数的运行前后，动态扩展函数的功能。&lt;/p&gt;
&lt;p&gt;看一看具体的适用方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 使用 “@” 语法糖来装饰函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了提高程序代码的可读性，以及让装饰器具备自己的鲜明特征，Python中使用 “@” 语法糖来构建函数间的装饰关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151008223151140&quot; alt=&quot;Python装饰器&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Python的交互模式中，不论多行还是单行语句都会在输入结束之后立即运行。Python中的 “@” 语法糖实际上是执行了一个这样的过程：&lt;/p&gt;
&lt;p&gt;police = person(police)&lt;/p&gt;
&lt;p&gt;因为上例中我们定义的person函数并没有返回任何类型的对象，所以police被重新赋值之后是NoneType，这也是为什么再次调用police()会出错的原因。&lt;/p&gt;
&lt;p&gt;那么该如何定义一个合格的装饰器函数呢？我们采用内嵌包装函数来实现。从上面的例子可以分析，我们需要person(police)执行结果返回一个函数，然后将police指向该函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151009222350193&quot; alt=&quot;Python装饰器&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们不难得到，之后调用的police函数实际上是指向了person中的decorate函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 装饰带参数的函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面给出的例子中被装饰函数不带参数，然而在实际应用中，往往被装饰的函数是带有自己的参数的，带参数的函数如何被装饰呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151009223021036&quot; alt=&quot;Python装饰器&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;police(&amp;#39;policewoman&amp;#39;)&lt;/code&gt; 的调用和未装饰前的调用方式完全一样，我们只需要向person中的decorate函数的定义中也添加对应的参数就可以了（因为它实际上调用的就是person中的decorate函数）。&lt;/p&gt;
&lt;p&gt;下面给出一个接受任意参数的装饰器例子（python中函数参数的几种形式在这里不做细究）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151009223659007&quot; alt=&quot;Python装饰器&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 装饰器带参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;装饰器可以为装饰函数添加一些额外的功能，作为函数本身，装饰器本身有时也需要传递参数，请看下例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151009224907848&quot; alt=&quot;Python装饰器&quot;&gt;&lt;/p&gt;
&lt;p&gt;带有参数的装饰器，在定义完成后实际执行了这样一个过程：&lt;code&gt;police = person(&amp;#39;person&amp;#39;)(police)&lt;/code&gt;，即先返回了decorate函数，然后执行 &lt;code&gt;decorate(police)&lt;/code&gt;，将police重新指向返回的wrapper函数。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;对Python装饰器的应该算是有了一个全貌的把握，原理很简单，应用的时候需要特别注意高阶函数的返回值和参数设置。多留一点心，少制造一些bug。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Python装饰器在实际的编码过程中使用非常广泛，它为Python中的函数编写提供了良好的扩展性，在拾获Python装饰器的相关概念、用法之前，我们先简单了解一下Python中函数的特性。&lt;/p&gt;
&lt;h2 id=&quot;函数对象&quot;&gt;&lt;a href=&quot;#函数对象&quot; class=&quot;headerlink&quot; title=&quot;函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h2&gt;&lt;p&gt;在Python中一切即对象。&lt;/p&gt;
&lt;p&gt;函数也不得不遵守Python界的自然法则。我们可以将函数作为参数进行传递。Python中，以自变量为参数的传递都是传递对象的引用。来看下面的例子：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="tomasran.space/category/Python/"/>
    
    
      <category term="装饰器" scheme="tomasran.space/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
      <category term="python" scheme="tomasran.space/tags/python/"/>
    
  </entry>
  
</feed>
